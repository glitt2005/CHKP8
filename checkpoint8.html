<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>myfile-find it</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="a-ejercicios-teóricos-checkpoint-8">A) EJERCICIOS TEÓRICOS CHECKPOINT 8</h1>
<hr>
<h1 id="¿qué-tipo-de-bucles-hay-en-js">1.  ¿Qué tipo de bucles hay en JS?</h1>
<p>Una de las formas más comunes de utilizar bucles o <strong>loops</strong> en JS es en colecciones de datos. Examinamos los diferentes tipos de bucles.</p>
<h2 id="bucle-bigforbig">1) Bucle <big><code>for</code></big>:</h2>
<p>El bucle <font color="green"><strong>for</strong></font> es el más clásico, y constituye  <strong>uno de los más antiguos y versátiles</strong> en JavaScript. Es ideal cuando necesitas un control preciso <strong>sobre el índice en cada iteración</strong> o necesitas <strong>manipular la secuencia</strong> de iteración.</p>
<h4 id="sintaxis">SINTAXIS</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span>inicialización<span class="token punctuation">;</span> condición<span class="token punctuation">;</span> actualización<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// código a ejecutar }</span>
</code></pre>
<h4 id="ejemplo--imprimimos-los-días-de-la-semana">EJEMPLO:  Imprimimos los días de la semana</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">var</span> diasDeLaSemana <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">"lunes"</span><span class="token punctuation">,</span>
    <span class="token string">"martes"</span><span class="token punctuation">,</span>
    <span class="token string">"miercoles"</span><span class="token punctuation">,</span>
    <span class="token string">"jueves"</span><span class="token punctuation">,</span>
    <span class="token string">"viernes"</span><span class="token punctuation">,</span>
    <span class="token string">"sábado"</span><span class="token punctuation">,</span>
    <span class="token string">"domingo"</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
<span class="token keyword">for</span> <span class="token punctuation">(</span>diaSemana <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> diaSemana <span class="token operator">&lt;</span> diasDeLaSemana<span class="token punctuation">.</span>length<span class="token punctuation">;</span> diaSemana<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>diasDeLaSemana<span class="token punctuation">[</span>diaSemana<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>NECESITAMOS:</p>
<ol>
<li>una <font color="green"><strong>variable iteradora</strong></font>. Aquí es  <code>diaSemana</code> será utilizada a lo largo del bucle y recorrerá cada elemento del array  <code>diasDeLaSemana</code>. Pero ojo! esta <strong>variable iteradora</strong> no representa un valor, sino un <strong>índice</strong>!</li>
<li>declarar <font color="green"><strong>una condición</strong></font>, es decir lo que queremos que se cumpla en el bucle. El bucle se parará cuando está condición ya no se cumpla. En nuestro caso, la condición es que sea menor que menor que 7.
<ul>
<li><strong>Ojo!</strong> ponemos <strong><code>&lt; 7</code> (o sea, hasta 6 inclusive</strong>) en lugar de <strong><code>&lt;=7</code></strong> porque recordemos que los <strong>índices comienzan en 0</strong> (no en 1). Por lo tanto siempre va a restar 1 del número total de los elementos del array.</li>
<li>Otra opción es poner un <strong>-1 al final</strong>, y funcionaría: <strong>sería cuestión de gustos</strong> en cuánto a qué te parece más fácil de leer.</li>
</ul>
</li>
</ol>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span>diaSemana <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> diaSemana <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>diasDeLaSemana<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> diaSemana<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>diasDeLaSemana<span class="token punctuation">[</span>diaSemana<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ol start="3">
<li>un tipo de <font color="green"><strong>incrementador</strong></font>:  <strong>var++</strong>, que aumentará en 1, cada vez que haga el bucle.</li>
</ol>
<h4 id="ventajas">VENTAJAS</h4>
<p>•	<strong>Control total sobre el índice</strong>: Puedes <strong>acceder y manipular el índice</strong> en cada iteración.<br>
•	<strong>Flexibilidad</strong>: Permite <strong>saltar o repetir elementos</strong> modificando el índice según sea necesario.<br>
•	<strong>Compatibilidad amplia</strong>: Funciona en <strong>todas las versiones de JavaScript</strong> y es ideal para estructuras de datos complejas como matrices bidimensionales.</p>
<h4 id="limitaciones">LIMITACIONES</h4>
<p>•	<strong>Propenso a errores</strong>: Es fácil <strong>olvidar incrementar el índice</strong> o establecer incorrectamente las condiciones del bucle.<br>
•	<strong>Código más verboso</strong>: Requiere <strong>más líneas de código</strong> en comparación con otras</p>
<h2 id="bucle-bigfor---inbig">2) Bucle <big><code>for - in</code></big>:</h2>
<p>El bucle <font color="green"><strong>for-in</strong></font> es más moderno que el anterior y tiene un <strong>lectura más sencilla y moderna</strong> para recorrer arrays. Generalmente se utiliza más que el bucle <font color="green"><strong>for</strong></font>.</p>
<ul>
<li><strong>Sin condiciones</strong></li>
<li><strong>Sin incrementadores</strong></li>
<li>El bucle <font color="green"><strong>for-in</strong></font>  interpreta que <strong>debe iterar tantas veces como elementos</strong> estén contenidos en la colección</li>
</ul>
<h4 id="sintaxis-1">SINTAXIS</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span>variable <span class="token keyword">in</span> objecto<span class="token punctuation">)</span>
  declaración
</code></pre>
<p><strong>CONVENCIÓN SINTÁCTICA</strong>:  Para el nombre de la <strong>variable iteradora</strong>, usamos el <strong>nombre de la lista</strong> pero <strong>en singular.</strong>  En el ejemplo siguiente, pondremos un nombre de array algo más largo (<code>diasDeLaSemana</code> ) para que se vea rápidamente la diferencia entre los dos.</p>
<h3 id="a-bucle-bigfor---inbig--en-arrays">a) Bucle <big><code>for - in</code></big>  en arrays:</h3>
<h4 id="ejemplo--imprimimos-los-días-de-la-semana-1">EJEMPLO:  Imprimimos los días de la semana</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">var</span> diasDeLaSemana <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">"lunes"</span><span class="token punctuation">,</span>
    <span class="token string">"martes"</span><span class="token punctuation">,</span>
    <span class="token string">"miercoles"</span><span class="token punctuation">,</span>
    <span class="token string">"jueves"</span><span class="token punctuation">,</span>
    <span class="token string">"viernes"</span><span class="token punctuation">,</span>
    <span class="token string">"sábado"</span><span class="token punctuation">,</span>
    <span class="token string">"domingo"</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
<span class="token keyword">for</span> <span class="token punctuation">(</span>diaSemana <span class="token keyword">in</span> diasDeLaSemana<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>diasDeLaSemana<span class="token punctuation">[</span>diaSemana<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Como vemos la sintaxis es más <strong>sencilla y corta</strong> que la anterior.</p>
<h3 id="b-bucle-bigfor---inbig---en-objetos">b) Bucle <big><code>for - in</code></big>   en objetos:</h3>
<ul>
<li>Esto <strong>muy común cuando llamamos a una API,</strong> es decir, salimos a otro servidor (por ejemplo, <em><strong>Twitter</strong></em>) y extraemos <em>tweets</em>. Éstos son <strong>con frecuencia enviados en formato objeto</strong>, es decir con una estructura de pares clave:valor.</li>
<li><strong>Si queremos mostrar esos datos en una página</strong>, la forma de hacerlo es <strong>iterando</strong> sobre esos datos, ese objeto.  Y una de las formas más comunes de hacerlo es mediante este bucle  <font color="green"><strong>for - in</strong></font>.</li>
</ul>
<h4 id="ejemplo--imprimimos-características-de-un-coche">EJEMPLO:  Imprimimos características de un coche</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> coche <span class="token operator">=</span> <span class="token punctuation">{</span>
  marca<span class="token punctuation">:</span> <span class="token string">"Toyota"</span><span class="token punctuation">,</span>
  modelo<span class="token punctuation">:</span> <span class="token string">"Auris"</span><span class="token punctuation">,</span>
  año<span class="token punctuation">:</span> <span class="token number">2013</span><span class="token punctuation">,</span>
  color<span class="token punctuation">:</span> <span class="token string">"Rojo"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propiedad <span class="token keyword">in</span> coche<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"La propiedad "</span> <span class="token operator">+</span> propiedad <span class="token operator">+</span> <span class="token string">" tiene el valor: "</span> <span class="token operator">+</span> coche<span class="token punctuation">[</span>propiedad<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* Imprime:
La propiedad marca tiene el valor: Toyota
La propiedad modelo tiene el valor: Auris
La propiedad año tiene el valor: 2013
La propiedad color tiene el valor: Rojo
*/</span>
</code></pre>
<p><strong>NOTAS:</strong></p>
<ol>
<li><code>propiedad</code>es el <strong>elemento iterador</strong>, que representa a la <strong>clave</strong> del par <strong>clave:valor</strong> de cada objeto.</li>
<li>Precisamente como se trata de un objeto, <strong>para extraer el <code>valor</code>de objeto</strong> necesitaremos utilizar la sintaxis adecuada, que son los <strong>corchetes [ ].</strong></li>
</ol>
<p><strong>No funcionaría</strong> si utilizáramos la <em><strong>dot notation</strong></em> o anotación con puntos para objetos (nos devolvería <code>underfined</code> ).  Ciertamente éste último sistema de <strong>anotación por puntos</strong> es considerado <strong>una buena práctica</strong>, <strong>pero</strong> en ciertos casos, como en éste, donde la misma <strong>variable iteradora corresponde también a la clave</strong> del par clave:valor <strong>del objeto</strong>, necesitamos ser <strong>más específicos</strong> y utilizar <strong>la sintaxis de corchetes [ ].</strong></p>
<h2 id="bucle-bigforeachbig">3) Bucle <big><code>forEach()</code></big></h2>
<p>El método <big><code>forEach()</code></big>     es un <strong>método específico para arrays</strong> que ejecuta una función proporcionada una vez por cada elemento del array.</p>
<h4 id="sintaxis-2">SINTAXIS</h4>
<pre class=" language-javascript"><code class="prism  language-javascript">array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// código</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<br>
NECESITAMOS:
<ul>
<li><strong>Elemento iterador</strong>: nombre de la variable que representa cada elemento a iterar.</li>
<li><strong>Colección</strong>: sobre la que se van a iterar los elementos</li>
<li><strong>Instrucciones a ejecutar</strong>.  La función dentro de una función se llama función <strong>callback</strong>. Técnicamente no es una función normal, ya que esto sucede automáticamente.</li>
</ul>
<h4 id="ejemplo--imprimimos-los-días-de-la-semana-2">EJEMPLO:  Imprimimos los días de la semana</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">var</span> diasDeLaSemana <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">"lunes"</span><span class="token punctuation">,</span>
    <span class="token string">"martes"</span><span class="token punctuation">,</span>
    <span class="token string">"miercoles"</span><span class="token punctuation">,</span>
    <span class="token string">"jueves"</span><span class="token punctuation">,</span>
    <span class="token string">"viernes"</span><span class="token punctuation">,</span>
    <span class="token string">"sábado"</span><span class="token punctuation">,</span>
    <span class="token string">"domingo"</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
diasDeLaSemana<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>diaSemana<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>diaSemana<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<h4 id="ventajas-1">VENTAJAS</h4>
<p>•	Es relativamente nuevo; <strong>el más moderno, funcional y sencillo</strong> en Javascript.<br>
•	<strong>Sintaxis concisa:</strong> Más fácil de leer y escribir, especialmente con funciones flecha.<br>
• <strong>Evita errores de índice</strong>: No necesitas preocuparte por manejar el índice manualmente.<br>
•	<strong>Ideal para operaciones en cada elemento</strong>: Perfecto para aplicar una operación a cada elemento.</p>
<h4 id="limitaciones-1">LIMITACIONES</h4>
<p>•	<strong>No permite break o continue</strong>: No puedes interrumpir o saltar iteraciones dentro del bucle.<br>
•	<strong>Solo para arrays:</strong> No funciona directamente con otros iterables como cadenas o conjuntos.<br>
•	<strong>Asincronía limitada:</strong> <code>forEach ()</code><strong>no es ideal para</strong> manejar funciones asíncronas con <strong><code>async</code> - <code>await</code>,</strong> ya que no esperará a que cada operación termine.</p>
<h2 id="bucle-bigwhilebig-">4) Bucle <big><code>while</code></big> :</h2>
<h4 id="sintaxis-3">SINTAXIS</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// código</span>
  <span class="token comment">// llamado "cuerpo del bucle"</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Mientras la condición <code>condition</code> sea verdadera, el <code>código</code> del cuerpo del bucle será ejecutado.<br>
<br><br>
NECESITAMOS:</p>
<ul>
<li>
<p><strong>una variable iteradora</strong>  y la declaramos <strong>fuera del ámbito de bucle.</strong> Esto puede tener sus puntos negativos <strong>en caso de que no quieras que se tenga acceso a esta variable exterior</strong>  más tarde.</p>
</li>
<li>
<p>para evitar <strong>un bucle infinito</strong>, necesitamos <strong>el incrementador</strong> a fin de que haga cambiar el valor de la variable iterativa. Añadimos este elemento manualmente dentro del código a ejecutar, <strong>dentro de las llaves{}.</strong></p>
</li>
</ul>
 <br>
<h4 id="ejemplo--imprimimos-los-días-de-la-semana-3">EJEMPLO:  Imprimimos los días de la semana</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">var</span> diasDeLaSemana <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">"lunes"</span><span class="token punctuation">,</span>
    <span class="token string">"martes"</span><span class="token punctuation">,</span>
    <span class="token string">"miercoles"</span><span class="token punctuation">,</span>
    <span class="token string">"jueves"</span><span class="token punctuation">,</span>
    <span class="token string">"viernes"</span><span class="token punctuation">,</span>
    <span class="token string">"sábado"</span><span class="token punctuation">,</span>
    <span class="token string">"domingo"</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
   
<span class="token keyword">let</span> diaSemana <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token keyword">while</span> <span class="token punctuation">(</span>diaSemana <span class="token operator">&lt;</span> diasDeLaSemana<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>diasDeLaSemana<span class="token punctuation">[</span>diaSemana<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  diaSemana<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
<h2 id="bucle-bigdo---whilebig-">5) Bucle <big><code>do - while</code></big> :</h2>
<h4 id="sintaxis-4">SINTAXIS</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">do</span>
  statement
<span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Mientras la condición <code>condition</code> sea verdadera, el <code>código</code> del cuerpo del bucle será ejecutado.</p>
<h4 id="ejemplo--imprimimos-los-días-de-la-semana-4">EJEMPLO:  Imprimimos los días de la semana</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">var</span> diasDeLaSemana <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">"lunes"</span><span class="token punctuation">,</span>
    <span class="token string">"martes"</span><span class="token punctuation">,</span>
    <span class="token string">"miercoles"</span><span class="token punctuation">,</span>
    <span class="token string">"jueves"</span><span class="token punctuation">,</span>
    <span class="token string">"viernes"</span><span class="token punctuation">,</span>
    <span class="token string">"sábado"</span><span class="token punctuation">,</span>
    <span class="token string">"domingo"</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
   
<span class="token keyword">let</span> diaSemana <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>diasDeLaSemana<span class="token punctuation">[</span>diaSemana<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     diaSemana<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>diaSemana <span class="token operator">&lt;</span> diasDeLaSemana<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
</code></pre>
<br>
<p>Como vemos, el bucle <strong><code>do - while</code></strong>  tiene una sintaxis similar al bucle <strong><code>while</code></strong>  , pero casi al revés, ya que seguiría el concepto de “<strong>haz esto mientras se cumple esta condición</strong>”, y precisamente esta condición se pone a lo último, o sea, que <strong>la controla al final.</strong></p>
<br>
<p><strong>VENTAJAS</strong>:</p>
<ul>
<li>El hecho de que <strong>garantice que al menos va a recorrer el bucle una vez, proporciona información</strong>.</li>
<li>Permite definir l<strong>a lógica del bucle antes de evaluar la condición</strong>, lo que puede ser <strong>más conveniente en ciertos escenarios</strong>.<br>
<br></li>
</ul>
<p><strong>EJEMPLO DE APLICACIÓN</strong>:</p>
<p>Típíco en <strong>juegos</strong>, cuando queremos que siempre haga el proceso al menos una vez. Por ej. un <strong>jugador que juega y te aseguras de que lo haga al menos una vez,</strong> y si sigue ganando, puede comprobarlo en esa condición <strong><code>while</code></strong> y puede seguir iterando.</p>
<br>
<p><strong>LIMITACIONES</strong>:</p>
<ul>
<li>
<p><strong>Puede devolver  <code>undefined</code></strong><br>
Si ponemos que la variable iteradora <code>diaSemana</code> es <strong>10</strong>, nos devolvería  <strong><code>undefined</code></strong>  ; sin embargo con el bucle  <strong><code>while</code></strong> <strong>no imprimiría nada</strong>. El bucle   <strong><code>do - while</code></strong>   siempre <strong>va a ejecutar el programa al menos UNA VEZ</strong> (el otro no haría nada porque la condición está puesta al principio, y no se cumple si ponemos diaSemana = 10).</p>
</li>
<li>
<p><strong>Riesgo de bucles infinitos:</strong><br>
Si la condición del  <code>while</code>  nunca se vuelve <strong>falsa</strong>, <strong>el bucle se ejecutará indefinidamente</strong>, lo que puede causar problemas en la aplicación. Es crucial <strong>asegurarse de que la condición eventualmente se evalúe como falsa</strong> para evitar este problema.</p>
</li>
<li>
<p><strong>Menos común que otros bucles:</strong><br>
En comparación con los bucles  <strong><code>for</code></strong>  y  <strong><code>while</code></strong>, el  <strong><code>do...while</code></strong>  se usa <strong>con menos frecuencia</strong>, ya que a menudo se puede lograr la misma lógica con los otros tipos de bucles.</p>
</li>
<li>
<p><strong>Puede ser más difícil de entender:</strong><br>
Para algunos desarrolladores, la estructura del  <strong><code>do...while</code></strong>  <strong>puede resultar menos intuitiva que otros bucles</strong>, especialmente si no están familiarizados con su ejecución.</p>
</li>
</ul>
<br>
<hr>
<h1 id="¿cuáles-son-las-diferencias-entre-const-let-y-var">2 ¿Cuáles son las diferencias entre const, let y var?</h1>
<h2 id="variable--font-color-greenfont-faceconsolasfont-size--6--varfont">1. Variable  <font color="green"><font face="Consolas"><font size="6">  var</font></font></font></h2>
<ul>
<li>Durante muchos años, en JavaScript <strong>sólo existía</strong> la  variable <strong><code>var</code></strong>.</li>
<li>Cuando creamos un variable con <strong><code>var</code></strong>, estamos creando una <strong>variable GLOBAL</strong>, lo que significa que puede entrar en conflicto con otras variables, y hacer lo que se denomina como “<strong>contaminar la variable global</strong>”.
<ul>
<li>Puede llevar mucho tiempo averiguar <strong>qué está pasando exactamente</strong> en el programa, y también el <strong>solventar ese error de nombrado</strong>.</li>
<li>Por tanto, <strong>necesitamos controlar dónde están nuestras variables declaradas</strong> y dónde tenemos acceso a ellas, pero con <strong><code>var</code></strong>   esto es algo <strong>muy difícil de hacer</strong>.</li>
<li>Aunque te lo puedes encontrar o pueden existir situaciones donde puede ser útil, <strong>hoy en día no tiene demasiado sentido utilizar</strong> <strong><code>var</code></strong> en nuestro código.</li>
</ul>
</li>
<li>Otra diferencia particular de <strong><code>var</code></strong> es que <strong>tolera redeclaraciones</strong>:</li>
</ul>
<h4 id="ejemplo-1----var-tolera-redeclaraciones">EJEMPLO 1 :   <strong><code>var</code></strong> tolera redeclaraciones:</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">var</span> user <span class="token operator">=</span>  <span class="token string">"Pete"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> user <span class="token operator">=</span>  <span class="token string">"John"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John</span>
</code></pre>
<h4 id="ejemplo-2-----alcance-de-var">EJEMPLO 2:     alcance de <strong><code>var</code></strong>;</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">var</span> mensajeGlobal <span class="token operator">=</span> <span class="token string">"Hola, soy global!"</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">mostrarMensaje</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mensajeGlobal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Accede a la variable global</span>
<span class="token punctuation">}</span>

<span class="token function">mostrarMensaje</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Imprime "Hola, soy global!"</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mensajeGlobal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Imprime "Hola, soy global!"</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> dentroDeBloque <span class="token operator">=</span> <span class="token string">"Dentro de un bloque"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dentroDeBloque<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// Imprime "Dentro de un bloque", porque var ignora el bloque</span>
</code></pre>
<h2 id="variable--font-color-greenfont-faceconsolasfont-size--6--letfont">2. Variable  <font color="green"><font face="Consolas"><font size="6">  let</font></font></font></h2>
<ul>
<li><strong><code>let</code></strong> vino hace unos años, y se convirtió en una <strong>mejor</strong> manera de definir variables, ya que <strong>no contaminaba el espacio de nombramiento global</strong>.</li>
<li><strong><code>let</code></strong> permite <strong>reasignar el valor</strong> de la variable.</li>
<li>Como consecuencia,  era mucho más específico, estaba <strong>más limitado</strong>; si se creaba dentro de una función o se añadía a ella, <strong>sólo estaría disponible en esa función:</strong> no habría otros momentos en los que estuviera disponible.</li>
<li><strong><code>let</code></strong> limita el <strong>alcance</strong> de las variables <strong>al bloque donde se definen</strong>, evitando efectos secundarios no deseados en otros bloques de código.</li>
<li><strong><code>let</code></strong> <strong>no permite redeclarar</strong> la misma variable <strong>en el mismo ámbito</strong>, lo que ayuda a evitar errores.</li>
<li>El alcance de bloque de  <strong><code>let</code></strong> hace que el <strong>código sea más fácil de entender y mantener.</strong></li>
<li><strong>No tolera redeclaraciones</strong>:</li>
</ul>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">let</span> user<span class="token punctuation">;</span>
<span class="token keyword">let</span> user<span class="token punctuation">;</span>  <span class="token comment">// Identifier 'user' has already been declared</span>
</code></pre>
<br>
<p>EJEMPLO DE <strong><code>let</code></strong> vs. <strong><code>var</code></strong>;</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">===</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// El alcance es dentro del bloque if</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// El alcance es global</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 4</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span>
<span class="token punctuation">}</span> 

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5 - sigue igual, let- cambia solo bloque if</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 - ha cambiado: var- alcance global</span>
</code></pre>
<br>
<h2 id="variable--font-color-greenfont-faceconsolasfont-size--6--constfont">3. Variable  <font color="green"><font face="Consolas"><font size="6">  const</font></font></font></h2>
<ul>
<li>La  variable <strong><code>const</code></strong> es <strong>la más nueva</strong>, y es una abreviación de “<strong>constante</strong>”.</li>
<li>Su valor <strong>no puede ser reasignado después de su inicialización</strong>.</li>
<li>Se ha convertido en <strong>una de las más populares</strong> a la hora de declarar variables. Se puede ver en los desarrolladores que <strong>es la preferida por encima de las otras opciones</strong> .</li>
<li>En la <strong>mayoría de aplicaciones</strong> se ven sobre todo la <strong>variable <code>const</code>  y la  variable <code>let</code></strong>.</li>
<li>Por norma general en los programas modernos (especialmente en <strong><em>React</em>, <em>Angular</em></strong> o plataformas del estilo) se utiliza <strong>la  variable <strong><code>const</code></strong>.</strong></li>
</ul>
<p>EJEMPLO DE <strong><code>const</code></strong>:</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> objeto <span class="token operator">=</span> <span class="token punctuation">{</span>  
nombre<span class="token punctuation">:</span> <span class="token string">"Ejemplo"</span><span class="token punctuation">,</span>  
valor<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  
  
objeto<span class="token punctuation">.</span>valor <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> 
<span class="token comment">// Esto es válido, se puede modificar la propiedad de un objeto const. </span>

objeto <span class="token operator">=</span> <span class="token punctuation">{</span> nombre<span class="token punctuation">:</span> <span class="token string">"Nuevo"</span><span class="token punctuation">,</span> valor<span class="token punctuation">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token comment">// Esto daría error, no se puede reasignar la constante objeto.</span>
</code></pre>
<br>
<p>EJEMPLO DE <strong><code>const</code></strong> VS. <strong><code>let</code></strong>:<br>
<br></p>
<p><strong>1) <code>const</code> : esta variable no se puede cambiar</strong><sup>(*1)</sup></p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> casa  <span class="token operator">=</span>  <span class="token string">"Benidorm"</span><span class="token punctuation">;</span>  
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>casa<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
casa <span class="token operator">=</span> <span class="token string">"Marbella"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>casa<span class="token punctuation">)</span><span class="token punctuation">;</span>       

<span class="token comment">// Devuelve un error:</span>
<span class="token comment">//           "TypeError: Assignment to constant variable. </span>
</code></pre>
<p>(*1)<br>
<br></p>
<img src="iconoPrecauc.png" alt="icono de cuidado">
<p><strong>OJO!!</strong>  Si estamos utilizando la plataforma web <strong>CODEPEN</strong>, <strong>no nos va a mostrar el error</strong>, por ello en este caso deberíamos utilizar otras opciones, <strong>como la consola del navegador.</strong><br>
<br></p>
<p><strong>2)<code>let</code> : la variable se ha podido cambiar</strong></p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">let</span> casa  <span class="token operator">=</span>  <span class="token string">"Benidorm"</span><span class="token punctuation">;</span>  
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>casa<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//devuelve: "Benidorm"</span>
  
casa <span class="token operator">=</span> <span class="token string">"Marbella"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>casa<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//devuelve:"Marbella"     </span>
</code></pre>
<br>
<h4 id="buenas-prácticas">BUENAS PRÁCTICAS</h4>
<ul>
<li><strong>La variable <code>const</code> debería ser nuestra mejor opción por defecto</strong>.</li>
<li>Si es demasiado específica, usaríamos <strong><code>let</code></strong>.</li>
<li>Sin embargo, es difícil que veamos <strong><code>var</code></strong> en las aplicaciones modernas. No es que no pueda <strong>haber casos en los que necesitemos una variable global</strong>, en los que sería la ocasión para utiliar <strong><code>var</code></strong>, pero de normal no va a ser así.<br>
<br></li>
</ul>
<p>EN RESUMEN:</p>

<table>
<thead>
<tr>
<th>Variable</th>
<th>Propósito</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>var</code></strong></td>
<td><strong>solo</strong> situaciones donde necesitas un <strong>alcance de función específico</strong> (o para funciones de práctica y aprendizaje de codificación). <strong>Evitar el uso de  <strong><code>var</code></strong></strong> debido a sus problemas de ámbito y <em>hoisting</em></td>
</tr>
<tr>
<td><strong><code>let</code></strong></td>
<td>para variables que puedan ser <strong>reasignadas</strong></td>
</tr>
<tr>
<td><strong><code>const</code></strong></td>
<td>para declarar <strong>variables que no van a cambiar</strong> su valor a lo largo del programa</td>
</tr>
</tbody>
</table><br>
<hr>
<h1 id="¿qué-es-una-función-de-flecha">3 ¿Qué es una función de flecha?</h1>
<div align="center">
<img src="funcionFlecha0.png" width="20%">
</div>
<br>
<p>Una <strong>función flecha</strong> (o <em><strong>arrow function</strong></em>) es una  forma concisa de definir funciones anónimas, introducida en ES6 (EcmaScript <strong>2015</strong>).</p>
<p>Las funciones flecha <strong>son de las funciones más cruciales para aprender en Javascript</strong> ya que están por todos los lados. Su <strong>sintaxis</strong> es completamente <strong>diferente</strong> a cualquier otra declaración de variable.</p>
<h2 id="ejemplos-función-declarada-vs-función-flecha">Ejemplos FUNCIÓN DECLARADA vs FUNCIÓN FLECHA</h2>
<ol start="0">
<li><strong>SIN PARÁMETROS</strong></li>
</ol>
<pre class=" language-javascript"><code class="prism  language-javascript">
<span class="token comment">// a) sin parámetros, función declarada </span>
<span class="token keyword">function</span> <span class="token function">hello1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'Hello!'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sin parámetros, función declarada '</span> <span class="token operator">+</span> <span class="token function">hola1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>



<span class="token comment">// b) sin parámetros, función FLECHA</span>
<span class="token keyword">const</span> <span class="token function-variable function">hello2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'Hello!'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sin parámetros, función FLECHA '</span> <span class="token operator">+</span> <span class="token function">hola2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// c) sin parámetros, función FLECHA EN UNA SOLA LÍNEA</span>
<span class="token keyword">const</span> <span class="token function-variable function">hello3</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">'Hello!'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sin parámetros, funcíon FLECHA EN UNA SOLA LÍNEA  '</span> <span class="token operator">+</span> <span class="token function">hello3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<br>
<ol>
<li><strong>CON 1 PARÁMETRO</strong></li>
</ol>
<pre class=" language-javascript"><code class="prism  language-javascript">
<span class="token comment">// a) un parámetro, función declarada</span>
<span class="token keyword">function</span> <span class="token function">hello4</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'un parámetro, función declarada '</span> <span class="token operator">+</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">hello4</span><span class="token punctuation">(</span><span class="token string">'milburn'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// b) un parámetro, función FLECHA</span>
<span class="token keyword">const</span> <span class="token function-variable function">hello5</span> <span class="token operator">=</span> x <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span>  <span class="token string">'un parámetro, función FLECHA '</span> <span class="token operator">+</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">hello5</span><span class="token punctuation">(</span><span class="token string">'milburn'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// c) un parámetro, función FECHA EN UNA SOLA LÍNEA </span>
<span class="token keyword">const</span> <span class="token function-variable function">hello6</span> <span class="token operator">=</span> x <span class="token operator">=&gt;</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> x<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'un parámetro, función FECHA EN UNA SOLA LÍNEA '</span> <span class="token operator">+</span> <span class="token function">hello6</span><span class="token punctuation">(</span><span class="token string">'milburn'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<br>
<ol start="2">
<li><strong>CON 2 PARÁMETROS:</strong></li>
</ol>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token comment">// a) dos parámetros, función declarada</span>
<span class="token keyword">function</span> <span class="token function">hello7</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> y<span class="token punctuation">;</span> 
    
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dos parámetros, función declarada '</span> <span class="token operator">+</span> <span class="token function">hello7</span><span class="token punctuation">(</span><span class="token string">'milburn'</span><span class="token punctuation">,</span> <span class="token string">'gomes'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// b) dos parámetros, función FLECHA</span>
<span class="token keyword">const</span> <span class="token function-variable function">hello8</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'dos parámetros, función FLECHA '</span> <span class="token operator">+</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">hello8</span><span class="token punctuation">(</span><span class="token string">'milburn'</span><span class="token punctuation">,</span> <span class="token string">'gomes'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// c) dos parámetros, función FLECHA EN UNA SOLA LÍNEA</span>
<span class="token keyword">const</span> <span class="token function-variable function">hello9</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>  <span class="token string">"Hello, "</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> y<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dos parámetros, función FLECHA EN UNA SOLA LÍNEA '</span> <span class="token operator">+</span> <span class="token function">hello9</span><span class="token punctuation">(</span><span class="token string">'milburn'</span><span class="token punctuation">,</span> <span class="token string">'gomes'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<br>
<h3 id="dos-características-principales--su-sintaxis-y-su-manejo-del-bigthisbig">DOS CARACTERÍSTICAS PRINCIPALES:  SU SINTAXIS Y SU MANEJO DEL <big><code>this</code></big>:</h3>
<h2 id="sintaxis-concisa">1) Sintaxis concisa</h2>
<p><strong>COMPAREMOS</strong> LA SINTAXIS de los 3 tipos de función diferentes:<br>
<br></p>
<p>i.a ) <strong>EXPRESIÓN de Función Anónima</strong></p>
<div align="center">
<img src="expresionDeFuncion.png" width="55%" alt="expresionDefuncion">
</div>
<br>
<br>
<p>i.b ) <strong>EXPRESIÓN de Función Nombrada</strong></p>
<div align="center">
<img src="funcionDeclaradanombrada.png" width="60%" alt="función declarada nombrada">
</div>
<p>(El nombre  <code>decirHola</code>  es útil para identificar la función en los errores, pero no se usa para llamar a la función.)</p>
<br>
<br>
<br>
<br>
<p>ii ) <strong>DECLARACIÓN de función tradicional o regular</strong></p>
<div align="center">
<img src="funcionDeclarada.png" width="68%" alt="funcion declarada anónima">
</div>
<br>
<br>
<br>
<p>iii ) <strong>Función FLECHA</strong>:</p>
<div align="center">
<img src="funcionFlecha1.png" width="50%" alt="funcionFlecha1">
</div>
<br>
<br>
<p>En realidad, <strong>si comparamos una función regular con una flecha</strong>, en lugar de tener que escribir “<em><strong>function</strong></em>” cada vez que queremos declarar una función, eliminar esa palabra y utilizar <big><strong> =&gt; </strong></big>  justo delante de las llaves <big><strong> { } </strong></big>   para para declarar una función de flecha.</p>
<h2 id="particular-manejo-de-this">2) Particular manejo de <code>this</code></h2>
<p>La palabra clave <strong><code>this</code></strong> tiene un comportamiento diferente en las <strong>funciones flecha</strong>.  A diferencia de las funciones tradicionales, las funciones flecha <strong>no tienen su propio  <code>this</code></strong>, sino que heredan el  <strong><code>this</code></strong>  del contexto donde se definieron .  El valor de  <strong><code>this</code></strong>  dentro de una función flecha es el mismo que <strong>el de su entorno léxico (el contexto donde fue definida).</strong></p>
<h4 id="a-ejemplo---this--en-declaración-de-función">a) EJEMPLO - <strong><code>this</code></strong>  en DECLARACIÓN DE FUNCIÓN:</h4>
<ul>
<li>
<p>En el  <strong>contexto de llamada</strong>,  <strong><code>this</code></strong>  en una <strong>función regular</strong> se determina <strong>en el momento de la llamada</strong>, <strong>según cómo se invoque la función.</strong></p>
</li>
<li>
<p>Si una <strong>función regular se llama directamente</strong> o se pasa como <strong>callback sin un contexto</strong> específico, <strong><code>this</code></strong> dentro de esa función se referirá al <strong>objeto global</strong></p>
</li>
<li>
<p>De hecho, el principal problema al acceder a  <strong><code>this</code></strong>  dentro de una declaración de función en JavaScript es que  <strong>su valor depende del contexto de llamada de la función, no de dónde se declara</strong>.  Esto puede llevar a <strong>comportamientos inesperados si la función se pasa como callback o se usa en diferentes contextos,</strong> ya que  <strong><code>this</code></strong>  podría referirse a algo distinto a lo que se esperaba.</p>
</li>
</ul>
<p>En el siguiente caso, no podríamos acceder al ,  <strong><code>this</code></strong>  de la función <code>MiObjeto()</code> que necesitamos:</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">MiObjeto</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>valor <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">obtenerValor</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>valor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this se refiere a MiObjeto</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MiObjeto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">obtenerValor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Salida: 10</span>

<span class="token keyword">const</span> miFuncion <span class="token operator">=</span> obj<span class="token punctuation">.</span>obtenerValor<span class="token punctuation">;</span>
<span class="token function">miFuncion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Salida: undefined!!!!</span>

</code></pre>
<br>
<br>
<h4 id="b-ejemplo---this--en-función-flecha">b) EJEMPLO - <strong><code>this</code></strong>  EN FUNCIÓN FLECHA:</h4>
<p>El problema anterior quedaría resuelto con una función flecha de la siguiente manera:</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span>valor <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">obtenerValorFlecha</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>valor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this se refiere al objeto que la contiene</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span><span class="token function">obtenerValorFlecha</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Salida: 10</span>
</code></pre>
<br>
<h3 id="en-resumen">3) EN RESUMEN</h3>
<h4 id="ventajas-de-las-funciones-flecha">1. VENTAJAS DE LAS FUNCIONES FLECHA</h4>
<ul>
<li>
<p><strong>Contexto Léxico:</strong> A diferencia de las funciones regulares, las funciones flecha <strong>no tienen su propio enlace a  <code>this</code>.</strong> En cambio,  <code>this</code>  dentro de una función flecha <strong>se refiere al contexto léxico</strong>, es decir, al valor de  <code>this</code>  <strong>en el ámbito donde la función flecha fue definida. Esto evita errores comunes</strong> relacionados con el contexto de  <code>this</code>  al usar funciones de <em><strong>callback</strong></em> dentro de <strong>métodos de objetos o en otros contextos donde  <code>this</code>  podría cambiar dinámicamente.</strong></p>
</li>
<li>
<p><strong>Mayor concisión:</strong> Son ideales para funciones <strong>cortas</strong> y funciones que se pasan como <strong>argumentos a otras funciones</strong>.</p>
</li>
</ul>
<br>
<h4 id="limitaciones-de-las-funciones-flecha">2. LIMITACIONES DE LAS FUNCIONES FLECHA</h4>
<ul>
<li><strong>No pueden usarse como constructores</strong> (no se pueden llamar con <strong><code>new</code></strong>).</li>
<li><strong>No tienen su propio objeto <code>arguments</code></strong> con la lista de argumentos pasados a la función, ya que solo acceden a los argumentos del ámbito léxico que las rodea.</li>
<li>Su <strong><code>this</code></strong> se determina en el momento de la creación de la función, y se <strong>hereda del contexto léxico circundante, en lugar de ser definido dinámicamente.</strong><br>
<br><br></li>
</ul>
<h4 id="uso-recomendaado">3. USO RECOMENDAADO</h4>
<p>Son útiles <strong>cuando se quiere mantener el <code>this</code> del contexto envolvente</strong>, como en <em><strong>callbacks</strong></em> o <strong>métodos de objetos</strong> donde <strong>no</strong> se requiere que <strong><code>this</code> apunte al objeto que llama a la función.</strong></p>
<br>
<hr>
<h1 id="¿qué-es-la-deconstrucción-de-variables">4 ¿Qué es la deconstrucción de variables?</h1>
<p>En JavaScript, <strong>deconstrucción</strong> (<em>“desconstructing”</em>) y <strong>desestructuración</strong> (<em>“destructuring”</em>) son términos que se refieren a la misma característica del lenguaje, introducida en ECMAScript 6 (<strong>ES6</strong>). Ambos términos se utilizan indistintamente para describir la <strong>sintaxis que permite intercambiar valores de variables de manera más concisa.</strong></p>
<br>
<br>
<table>
<caption>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¿QUÉ HACEMOS AL <strong>DECONSTRUIR?</strong></caption>
    <tbody>
        <tr>
            <td rowspan="3" align="center">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extraer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
            <td rowspan="2" align="center"><h4>valores de arrays</h4></td>
         </tr>      
               <tr><td rowspan="3" align="center">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;para asignarlos a variables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>   
          </tr><tr>
            <td align="center"><h4>propiedades de objetos</h4></td>
        </tr>
    </tbody>
</table>
<br>
<br>
<p><strong>VENTAJAS</strong>:</p>
<ul>
<li>
<p>el código <strong>más legible</strong></p>
</li>
<li>
<p><strong>evita</strong> la necesidad de <strong>acceder repetidamente</strong> a los elementos de la estructura original.</p>
</li>
<li>
<p><strong>Código más limpio y legible:</strong> Evita la necesidad de <strong>acceder a las propiedades del objeto usando la notación de punto</strong> (<code>variable.atributo</code>).</p>
</li>
<li>
<p><strong>Extracción selectiva:</strong> Permite extraer <strong>solo las propiedades necesarias</strong>, ignorando las demás.</p>
</li>
<li>
<p><strong>Asignación múltiple:</strong> Se pueden asignar <strong>múltiples variables en una sola línea</strong>.<br>
<br></p>
</li>
</ul>
<p><strong>NOTA</strong>:</p>
<ul>
<li>La destructuración <strong>no cambia la variable en sí misma.</strong> Crea nuevas variables y asigna valores extraidos de la estructura de datos original. <strong>La variable original queda intacta</strong>.<br>
<br></li>
</ul>
<h3 id="intercambio-de-valores-de-variable">1. INTERCAMBIO DE VALORES DE VARIABLE:</h3>
<p>Un ejemplo básico para el intercambio de turnos en un juego sería hacer uso de la desestructuración <strong>para intercambiar los valores de las variables que representan los jugadores actuales</strong>.</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">let</span> jugador1 <span class="token operator">=</span> <span class="token string">"X"</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> jugador2 <span class="token operator">=</span> <span class="token string">"O"</span><span class="token punctuation">;</span>

<span class="token comment">// Intercambio de turnos usando desestructuración</span>
<span class="token punctuation">[</span>jugador1<span class="token punctuation">,</span> jugador2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>jugador2<span class="token punctuation">,</span> jugador1<span class="token punctuation">]</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jugador1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: O</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jugador2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: X</span>
</code></pre>
<p>En este ejemplo, la línea  <code>[jugador1, jugador2] = [jugador2, jugador1];</code> realiza la magia:</p>
<p>&nbsp; 1. <strong>Se crea un array</strong> con los valores actuales de  <code>jugador2</code>  y  <code>jugador1</code>.<br>
&nbsp; 2. Luego, la desestructuración <strong>asigna el primer valor</strong> (<strong>anteriormente el de  <code>jugador2</code></strong>) a  <strong><code>jugador1</code></strong>  y el segundo valor (anteriormente el de  <code>jugador1</code>) a  <code>jugador2</code>, logrando así el intercambio.</p>
<h4 id="ventaja">VENTAJA</h4>
<p>Nos <strong>evita</strong>  la tediosa tarea de cambiar,  <strong>uno por uno</strong>, el valor de cada uno de los jugadores <code>jugadorx.nombre</code></p>
<h4 id="aplicación">APLICACIÓN</h4>
<p>Una de los procesos más comunes que te encuentras cuando estás implementando,  es <strong>la capacidad de intercambiar los valores de las variables</strong>. Esto es lo que se hace en  procesos de tipo “<em><strong>quicksort</strong></em>” u “ordenamiento rápido” (<em>algoritmo de ordenación que funciona bajo el principio de “divide y vencerás”</em>) u otros algoritmos más avanzados. <strong>Sin la deconstruccion de variables</strong>, sería este procedimiento se convertiría en todo <strong>un reto</strong>! Por suerte, en <strong>las versiones modernas de JavaScript</strong> podemos hacer esto de manera <strong>más eficiente en una sola línea de código.</strong></p>
<br>
<h3 id="deconstrucción-de-arrays">2. DECONSTRUCCIÓN DE ARRAYS:</h3>
<p>La desestructuración de arrays o arreglos permite extraer elementos específicos de un array, y asignarlos a variables, utilizando <strong>la posición de los elementos dentro del array.</strong></p>
<p>En el siguiente ejemplo, <strong>las dos comas extras (,) sustituyen</strong> cada una de ellas a un elemento del array <strong>en ese orden</strong>:<br>
<br></p>
<h4 id="arrays---ejemplo-1">Arrays - EJEMPLO 1</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> numeros <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// Desconstrucción de un array</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>primero<span class="token punctuation">,</span> segundo<span class="token punctuation">,</span> <span class="token punctuation">,</span> <span class="token punctuation">,</span> quinto<span class="token punctuation">]</span> <span class="token operator">=</span> numeros<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>primero<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>segundo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>quinto<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Output: 5</span>
</code></pre>
<br>
<p>En esencia, la <strong>desconstrucción</strong> facilita la extracción de datos de estructuras complejas como <strong>arreglos y objetos</strong> y su asignación a variables separadas, y poder hacer por ejemplo <strong>comparaciones, reordenaciones, etc.</strong> En lugar de acceder mediante índices, atributo por atributo, podemos acceder simultáneamente a todos estas propiedades o valores.</p>
<p>En el EJEMPLO 1,  habría resultado <strong>mucho más largo y tedioso</strong> el hacer algo como:</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> numeros <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// Sin desconstrucción del array</span>

<span class="token keyword">const</span> itemPrimero <span class="token operator">=</span> numeros<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>itemPrimero<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Output: 1</span>

<span class="token keyword">const</span> itemSegundo <span class="token operator">=</span> numeros<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>itemSegundo<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Output: 2</span>

<span class="token keyword">const</span> itemQuinto <span class="token operator">=</span> numeros<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>itemQuinto<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Output: 5</span>

</code></pre>
<p>… y luego, además, nos tocaría realizar la demás codificación para utilizar esas variables, etc.<br>
<br></p>
<h3 id="deconstrucción-de-objetos">3. DECONSTRUCCIÓN DE OBJETOS:</h3>
<p>La desestructuración de objetos permite extraer <strong>propiedades específicas de un objeto y asignarlas a variables</strong>, bien mediantes <strong>nombres iguales</strong> a las propiedades, o con nombres distintos usando un <strong>alias</strong>.<br>
<br></p>
<h4 id="objetos---ejemplo-1">Objetos - EJEMPLO 1:</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> persona <span class="token operator">=</span> <span class="token punctuation">{</span>  nombre<span class="token punctuation">:</span> <span class="token string">'Sammy'</span><span class="token punctuation">,</span>  edad<span class="token punctuation">:</span> <span class="token number">45</span><span class="token punctuation">,</span>  ciudad<span class="token punctuation">:</span> <span class="token string">'Madrid'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// Desconstrucción con nombres de variables iguales a las propiedades</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> nombre<span class="token punctuation">,</span> edad<span class="token punctuation">,</span> ciudad <span class="token punctuation">}</span> <span class="token operator">=</span> persona<span class="token punctuation">;</span> 

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nombre<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Sammy</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>edad<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Output: 30</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ciudad<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Madrid</span>

<span class="token comment">// Desconstrucción con alias</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> nombre<span class="token punctuation">:</span> nombrePersona<span class="token punctuation">,</span> edad<span class="token punctuation">:</span> edadPersona <span class="token punctuation">}</span> <span class="token operator">=</span> persona<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nombrePersona<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Sammy</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>edadPersona<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Output: 45</span>
</code></pre>
<br>
<h4 id="objetos---ejemplo-2">Objetos - EJEMPLO 2:</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> jugador <span class="token operator">=</span> <span class="token punctuation">{</span>
  nombre<span class="token punctuation">:</span> <span class="token string">"Messi"</span><span class="token punctuation">,</span>
  posicion<span class="token punctuation">:</span> <span class="token string">"Delantero"</span><span class="token punctuation">,</span>
  dorsal<span class="token punctuation">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Desconstrucción del objeto jugador</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> nombre<span class="token punctuation">,</span> posicion<span class="token punctuation">,</span> dorsal <span class="token punctuation">}</span> <span class="token operator">=</span> jugador<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nombre<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Imprime: Messi</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>posicion<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Imprime: Delantero</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dorsal<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Imprime: 10</span>
</code></pre>
<br>
<img src="iconoPrecauc.png" alt="icono de cuidado">
<p><strong>OJO!!</strong> Lo hemos mencionado, pero recalcamos que  <strong>los nombres que ponemos para la extracción o deconstrucción deben coincidir exactamente con los nombres de las claves del objeto.</strong><br>
En general, si ponemos otros nombres a los argumentos sí funcionaría, <strong>pero no en deconstrucción</strong>. En este último para poder <strong>mapear a los atributos de la variable</strong> <code>jugador</code>,  <strong>al deconstruir</strong> debemos pasar <strong>estos mismos nombres con exactitud</strong>, es decir,   <code>nombre</code>, <code>posición</code>y <code>dorsal</code>.</p>
<br>
<br>
<h3 id="desconstrucción-con-parámetros-de-funciones">4. DESCONSTRUCCIÓN CON PARÁMETROS DE FUNCIONES:</h3>
<p>La desestructuración también se puede utilizar <strong>al pasar argumentos a funciones.</strong></p>
<br>
<h4 id="parámetros-de-funciones---ejemplo-1">Parámetros de funciones - EJEMPLO 1:</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">mostrarInfo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> nombre<span class="token punctuation">,</span> edad <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Nombre: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>nombre<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, Edad: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>edad<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> persona2 <span class="token operator">=</span> <span class="token punctuation">{</span> nombre<span class="token punctuation">:</span> <span class="token string">'Ana'</span><span class="token punctuation">,</span> edad<span class="token punctuation">:</span> <span class="token number">25</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">mostrarInfo</span><span class="token punctuation">(</span>persona2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Output: Nombre: Ana, Edad: 25</span>
</code></pre>
<br>
<h4 id="parámetros-de-funciones---ejemplo-2">Parámetros de funciones - EJEMPLO 2:</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">mostrarNumeros</span><span class="token punctuation">(</span><span class="token punctuation">[</span>primero<span class="token punctuation">,</span> segundo<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`
    Primer número: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>primero<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, 
    Segundo número: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>segundo<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
    `</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token function">mostrarNumeros</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Primer número: 10, Segundo número: 20</span>
</code></pre>
<p><strong>NOTA</strong>: Debemos llamar a la función siempre teniendo en cuenta <strong>el tipo de datos que contiene</strong>. En el Ejemplo 2, vemos que la función  <code>mostrarNumeros()</code> contiene <strong>un parámetro conteniendo un array:</strong> <code>[primero, segundo]</code>, y por tanto, cuando la invoquemos debemos utilizar <strong>la misma sintaxis con corchetes [].</strong><br>
<br></p>
<h3 id="valores-por-defecto">5. VALORES POR DEFECTO:</h3>
<p>Muchas veces <strong>no conocemos los valores que obtendremos, sea como resultado de una petición API</strong> o  datos de formularios o de cualquier otra fuente con los que tratemos con <strong>objetos</strong>.  A menudo sólo tenemos trozos de lo que necesitamos.</p>
<p>Por ello, necesitaremos poner unos <strong>valores por defecto</strong> para esos objetos.<br>
<br></p>
<h4 id="sintaxis-deconstrucción-con-parámetros-de-funciones">SINTAXIS deconstrucción con parámetros de funciones:</h4>
<p>La <strong>sintaxis</strong> muy parecida a cómo utilizamos los argumentos por defecto en los tipos de valores de variable normales <strong>cuando simplemente pasas un único elemento como argumento</strong>. Pero ahora debemos integrar eso en un objeto.</p>
<p>La deconstrucción permite establecer valores por defecto para las variables, <strong>en el eventual caso de que la propiedad o elemento del array  no exista.</strong><br>
<br></p>
<h4 id="ejemplos">EJEMPLOS</h4>
<p>a) EL VALOR QUE PASAMOS AL DECONSTRUIR <strong>ES UTILIZADO</strong>-No existía valor declarado</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> usuario <span class="token operator">=</span> <span class="token punctuation">{</span> nombre<span class="token punctuation">:</span> <span class="token string">'Sammy'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> nombre<span class="token punctuation">,</span> edad <span class="token operator">=</span> <span class="token number">45</span> <span class="token punctuation">}</span> <span class="token operator">=</span> usuario<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nombre<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Sammy</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>edad<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Output: 45</span>
</code></pre>
<p>En este caso <strong>la variable <code>usuario</code> no contiene</strong> el par clave:valor correspondiente a la clave de <strong><code>edad</code></strong>, por lo que al deconstruir, podemos añadir el nombre de la edad a la variable y por tanto nuestro nuevo dato <strong>es utilizado por defecto</strong>.</p>
<br>
<p>b) EL VALOR QUE PASAMOS AL DECONSTRUIR <strong>ES IGNORADO</strong>- Existía valor declarado</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> usuario <span class="token operator">=</span> <span class="token punctuation">{</span> nombre<span class="token punctuation">:</span> <span class="token string">'Sammy'</span><span class="token punctuation">,</span> edad<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> nombre<span class="token punctuation">,</span> edad <span class="token operator">=</span> <span class="token number">45</span> <span class="token punctuation">}</span> <span class="token operator">=</span> usuario<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nombre<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Sammy</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>edad<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Output: 10</span>
</code></pre>
<p>En este caso <strong>la variable <code>usuario</code> ya contiene</strong> el valor de <strong><code>edad</code></strong>, con lo que  <strong>ignora por completo la clave que pasamos al deconstruir</strong>, ya que sólo lo utilizará realmente en caso de no existir en la variable.</p>
<br>
<h3 id="aplicaciones">6. APLICACIONES</h3>
<ul>
<li>Aplicaciones que nos encontramos a diario en la que utilizamos la deconstrucción de arrays y objetos en JavaScript es <strong>al conectarse con una API externa</strong>.</li>
<li>La <strong>API</strong> devuelve típicamente <strong>estructuras tipo array y objetos</strong> (con todo tipo de claves y valores diferentes).</li>
</ul>
<p><strong>En versiones antiguas de JavaScript</strong> tenías que</p>
<ul>
<li><strong>crear</strong> algún tipo de función que sacara cada uno de esos valores,</li>
<li><strong>iterar</strong> sobre las claves,</li>
<li><strong>almacerlas</strong> en variables, y</li>
<li><strong>pasarlas en la función</strong> que estés creando.</li>
</ul>
<p>Pero en <strong>versiones modernas de JavaScript</strong>, lo que realmente se puede utilizar es la <strong>deconstrucción</strong> del objeto.</p>
<p>Una vez hemos identificado el <strong>nombre del objeto u array</strong> a deconstruir, nos <strong>facilita enormemente la extracción de estos datos específicos de estructuras complejas</strong>, así como su asignación a variables individuales, que de otro modo sería tan <strong>tedioso</strong> trabajar con los tipos de datos que una <strong>API</strong> devuelve.<br>
<br><br>
<br><br>
<br></p>
<hr>
<h1 id="¿qué-hace-el-operador-de-extensión-en-js">5 ¿Qué hace el operador de extensión en JS?</h1>
<p><strong>El operador de extensión</strong> (también llamado operador de propagación) o <strong>Spread Operator</strong> es una herramienta muy potente de las plataformas más populares de JavaScript. Básicamente, <strong>toma los elementos de un iterable</strong> (arrays, cadenas, u objetos) <strong>y los “desempaqueta” individualmente</strong>.</p>
<p><strong>OBJETIVO</strong>: Su objeto es facilitar <strong>la manipulación y combinación de datos de manera concisa</strong>.<br>
<strong>SINTAXIS</strong>: 3 puntos seguidos (…) de algún tipo de palabra.</p>
<h2 id="convertir-cadenas-en--arrays">1. CONVERTIR CADENAS EN  ARRAYS</h2>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">let</span> cadena <span class="token operator">=</span> <span class="token string">"Mundo"</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>cadena<span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["M", "u", "n", "d", "o"]</span>
</code></pre>
<br>
<h2 id="combinar--arrays">2. COMBINAR  ARRAYS</h2>
<p>a) Comparemos poniendo el <strong>operador de extensión</strong>:</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> newNumbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>newNumbers<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//imprime [ 1, 2, 3, 4, 5, 8, 9 ]</span>
</code></pre>
<br>
<img src="iconoPrecauc.png" alt="icono de cuidado">
<p><strong>OJO!!</strong> Recordemos que <strong>el método<code>push()</code> cambia la variable original.</strong><br>
<br></p>
<p>b) <strong>Si no pusiéramos la extensión …</strong> entonces lo añadiría como <strong>un único</strong> elemento, un <strong>array (anidado</strong>):</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> newNumbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>newNumbers<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//imprime [ 1, 2, 3, 4, [ 8, 9 ] ]</span>
</code></pre>
<p>precisamente por cómo JavaScript interpreta los arrays:  <strong>un conjunto de “cualquier tipo de datos”.</strong>  La solución, pues es utilizar el operador de extensión.</p>
<br>
<h2 id="copiar-arrays">3. COPIAR ARRAYS</h2>
<ul>
<li>Cuando trabajas con arrays basados en <strong>React</strong>, <strong>Angular</strong> y otras plataformas de JavaScript, se sobreentiende que <strong>no tienes que hacer cambios en una estructura de datos ya creada</strong>: esto se trata en realidad de una CONVENCIÓN COMÚN.</li>
<li>Una variable declarada con <strong>const</strong> nos da precisamente esa seguridad, ya que nos daría error si más tarde en el programa intentamos cambiar la estructura de datos de esta variable.</li>
<li>Otra situación que puede pasar, es que <strong>añadamos un string</strong> a algo en este array que contiene números, y luego <strong>otra parte del programa considera que solo había números enteros</strong> (porque en principio era así), y ejecuta un proceso sobre esa estructura:  <strong>nos daría error</strong>.<br>
<br></li>
</ul>
<h4 id="buenas-prácticas-1">BUENAS PRÁCTICAS</h4>
<ul>
<li>
<p>Lo más <strong>limpio y seguro</strong> es hacer una <strong>copia</strong> de esa variable original, y luego usar <strong>let</strong> para hacer nuestras modificaciones.<br>
De esta forma <strong>evitamos crear los menos efectos secundarios posibles</strong></p>
</li>
<li>
<p>Debido a que <strong>el método <code>push()</code>, como ya hemos dicho, cambia la variable original</strong>, si hacemos la siguiente asignación con la intención de realizar una copia, seguiríamos con <strong>problema</strong>:</p>
</li>
</ul>
<h4 id="ejemplo-con-push">EJEMPLO con <code>push()</code></h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> updatedNumbers <span class="token operator">=</span> numbers<span class="token punctuation">;</span>

updatedNumbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//imprime  [ 1, 2, 3, 4, 5 ]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>updatedNumbers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//imprime  [ 1, 2, 3, 4, 5 ]</span>
</code></pre>
<p>Vemos que <strong>cambia las dos variables</strong>.<br>
<br><br>
<br><br>
<img src="interrogacion.png" align="left" width="90">   <big><br><strong>¿QUÉ ESTÁ PASANDO EXACTAMENTE?</strong></big></p>
<br>
<br>
<br>
<p>Lo que está ocurriendo es que aquí <strong>no está pasando una copia, sino una referencia</strong>. Y lo que esto significa es que si haces una modificación en <strong>updatedNumbers</strong>, también lo haces en <strong>numbers</strong>,  y como consecuencia estás <strong>modificando también la variable original.</strong><br>
<br><br>
Tenemos <strong>dos soluciones</strong> a esto:<br>
<br></p>
<h3 id="a-forma-tradicional-añadir-bigslicebig-a-la-variable-original">a) Forma tradicional: añadir <code>slice()</code> a la variable original</h3>
<p>El método  <code>slice()</code>  en JavaScript se utiliza para extraer una porción de una array. Cuando se llama <strong>sin argumentos</strong> toma todos los elementos del array, o sea, <strong>crea una copia de todos los elementos del array original</strong>.</p>
<h4 id="ejemplo---slice">EJEMPLO - <code>slice()</code></h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> updatedNumbers <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

updatedNumbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//imprime  [ 1, 2, 3, 4]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>updatedNumbers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//imprime  [ 1, 2, 3, 4, 5 ]</span>
</code></pre>
<br>
<h3 id="b-forma-moderna-operador-de-extensión">b) Forma moderna: operador de extensión</h3>
<h4 id="sintaxis-5">SINTAXIS:</h4>
<p><code>[…variableOriginal];</code><br>
<br></p>
<h4 id="ejemplo---operador-de-extensión">EJEMPLO - operador de extensión:</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> updatedNumbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>numbers<span class="token punctuation">]</span><span class="token punctuation">;</span>

updatedNumbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//imprime [ 1, 2, 3, 4 ]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>updatedNumbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//imprime [ 1, 2, 3, 4, 5 ]</span>
</code></pre>
<br>
<p>Vemos que <strong>cambia las dos variables</strong>.<br>
<br><br>
<br><br>
<br><br>
<br><br>
<img src="interrogacion.png" align="left" width="90">   <big><br><strong>¿FORMA TRADICIONAL O MODERNA?</strong></big></p>
<br>
<br>
<br>
<ul>
<li>
<p>Se  ven  <strong>los dos tipos</strong> de comportamientos en las aplicaciones reales, ya que los desarrolladores han aplicado ambos durante muchos años: el método <strong><code>slice()</code></strong> ha estado siempre <strong>muy extendido</strong>.</p>
</li>
<li>
<p>Sin embargo, en los últimos años, y si miramos en las aplicaciones creadas en <strong>Angular</strong>, o <strong>View</strong>, se aprecia <strong>cada vez con más frecuencia la predominancia del operador de extensión</strong>.</p>
</li>
</ul>
<p>Ambos funcionan de igual manera, pero quizá la <strong>tendencia es a usar más la última forma más moderna.</strong> No obstante es importante conocer los dos y tener ambas posibilidades.<br>
<br><br>
<br></p>
<p><strong>NOTA</strong>:<br><br>
El tipo de copia que se crea en estos casos es una <strong>copia superficial</strong>, en comparación con una <strong>copia profunda</strong> :</p>
<ul>
<li>
<p>una <strong>copia superficial</strong> (<em>shallow copy</em>) crea un nuevo objeto, pero los elementos internos (si son objetos o arrays) <strong>son referenciados desde el objeto original</strong>.</p>
</li>
<li>
<p>una <strong>copia profunda</strong> (<em>deep copy</em>), por otro lado, crea un nuevo objeto y <strong>copia recursivamente todos los elementos</strong>, es decir, <strong>incluyendo los objetos y arrays anidados</strong>, para que no compartan referencias con el objeto original.</p>
</li>
</ul>
<br>
<br>
<h2 id="pasar-argumentos-a-funciones">4.  PASAR ARGUMENTOS A FUNCIONES</h2>
<p>Esto es algo <strong>muy común</strong>. Para explicarlo, tomaremos de la biblioteca, el objeto <strong>Math</strong> (disponible en todo JavaScript), y utilizaremos <strong>el método<code>max()</code></strong>.  Este método:</p>
<ul>
<li>se utiliza para encontrar <strong>el valor más grande de una lista de números</strong></li>
<li><strong>si</strong> se proporciona un argumento que <strong>no es un número</strong>,  <code>Math.max()</code>  <strong>devuelve  <code>NaN</code></strong>  (Not a Number)</li>
</ul>
<br>
<h4 id="ejemplo-1---cómo-funcióna-math.max">EJEMPLO 1 - cómo funcióna <code>Math.max()</code>:</h4>
<pre class=" language-javascript"><code class="prism  language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// devuelve 10 </span>
</code></pre>
<p>Aquí estamos pasando una lista, como si fueran 6 argumentos.</p>

<br>
<h4 id="ejemplo-2---pasando-argumento-como-función">EJEMPLO 2 - pasando argumento como función:</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// NaN</span>
</code></pre>
<p>Aquí la cosa es diferente: en este caso, interpreta que sólo estamos pasando <strong>1 argumento</strong>, cuyo tipo de dato es <strong>un array, no un número</strong>. Por esto el output de <strong>NaN.</strong></p>
<p>Para arreglar esto, solo tenemos que añadir la <strong>sintaxis de los tres puntos (…) del operador de extensión</strong> y así poder implementar la <strong>deconstrucción del array</strong>:</p>
<h4 id="ejemplo-3---operador-de-extensión">EJEMPLO 3 - operador de extensión</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span> <span class="token punctuation">(</span><span class="token operator">...</span>numbers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 10</span>
</code></pre>
<p>Finalmente conseguimos hacerlo:  lo convierte en un conjunto de argumentos de función, que en este caso son <strong>números.</strong></p>
<p>Este proceso <strong>es muy típico en las plataformas modernas de JavaScript.</strong><br>
<br></p>
<br>
<h2 id="combinación-de-propiedades-de-varios-objetos-en-uno-nuevo">5. COMBINACIÓN DE PROPIEDADES DE VARIOS OBJETOS EN UNO NUEVO</h2>
<p>Utilizando la <strong>deconstrucción de objetos</strong>, vamos a extraer los valores dentro del objeto de la variable, y los tenemos de dos tipos:</p>
<ul>
<li>Valores que son <strong>fijos</strong>: necesitamos que siempre estén ahí</li>
<li>Otros valores <strong>opcionales</strong> que <strong>pueden estar o no</strong>, y tampoco conocemos el número de ello.</li>
</ul>
 <br>
<p>A) EXTRAYENDO LOS ELEMENTOS FIJOS:</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{</span>abridor<span class="token punctuation">,</span>cerrador<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    abridor<span class="token punctuation">:</span> <span class="token string">'Verlander'</span><span class="token punctuation">,</span>
    cerrador<span class="token punctuation">:</span> <span class="token string">'Giles'</span><span class="token punctuation">,</span>
    relevo_1<span class="token punctuation">:</span> <span class="token string">'Morton'</span><span class="token punctuation">,</span>
    relevo_2<span class="token punctuation">:</span> <span class="token string">'Gregerson'</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>abridor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Verlander"</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cerrador<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Giles"</span>
</code></pre>
<br>
Para **los fijos**: ponemos **las claves** como parte del **nombre de la variable.**
<br>
<br>
<p>B) EXTRAYENDO LOS ELEMENTOS OPCIONALES O VARIABLES:</p>
<p>Añadiremos un elemento más como parte del nombre de la variable (de tipo “objeto”), haciendo uso del <strong>operador de extensión</strong> o <em>spread operator</em>:</p>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{</span>abridor<span class="token punctuation">,</span>cerrador<span class="token punctuation">,</span> <span class="token operator">...</span>relevos<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    abridor<span class="token punctuation">:</span> <span class="token string">'Verlander'</span><span class="token punctuation">,</span>
    cerrador<span class="token punctuation">:</span> <span class="token string">'Giles'</span><span class="token punctuation">,</span>
    relevo_1<span class="token punctuation">:</span> <span class="token string">'Morton'</span><span class="token punctuation">,</span>
    relevo_2<span class="token punctuation">:</span> <span class="token string">'Gregerson'</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>abridor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Verlander"</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cerrador<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Giles"</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>relevos<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { relevo_1: 'Morton', relevo_2: 'Gregerson' }</span>
</code></pre>
<br>
<p><strong>A traves de la sintaxis <big><code>...elemento</code></big></strong>,  haremos mapear este elemento <strong>al resto de los elementos</strong> que contiene la variable y nos <strong>imprime un objeto con los pares la clave-valor del resto de los elementos</strong>.</p>
<p>Como hemos visto en el punto nº 4, ésta es la forma que trabaja <strong>la deconstrucción</strong>:</p>
<ul>
<li>si pasamos un valor tal como <code>abridor</code>, lo busca en la variable (que es un objeto) y encuentra la clave, la mapea e imprime su valor.</li>
<li><strong>Los tres puntos <code>...</code> crea un grupo abierto con un número de elementos indeterminado</strong>, que mapeará al resto de elementos en cuanto creamos un variable para ello.</li>
</ul>
<p>Es una de las formas más comunes de hacer <strong>la deconstrucción de objetos</strong> utilizado por muchas plataformas como <em><strong>React</strong></em> cuando <strong>no sabemos cuántos argumentos habrá</strong> y necesitamos extraer todo lo que haya, con el fin de  <strong>guardarlo en una variable que podemos utilizar más tarde</strong>.</p>
<img src="iconoPrecauc.png" alt="icono de cuidado">
<p><strong>OJO!!  El operador de extensión … debe colocarse al final de los demás elementos del objeto</strong>.  Generaríamos un error si tratamos de hacer <code>const {abridor, ...relevos, cerrador}....</code>. Este error, diría algo así como <code>// SyntaxError: Rest element must be last element</code>.</p>
<br>
<hr>
<h1 id="¿qué-es-la-programación-orientada-a-objetos">6 ¿Qué es la programación orientada a objetos?</h1>
<br>
<h2 id="introducción">1. INTRODUCCIÓN</h2>
<ul>
<li><strong>Durante años</strong>, las versiones antiguas de <strong>JavaScript no incluían</strong> los componentes de programación orientada a objetos, como <strong>clases e instanciación</strong>, lo cual estuvo bien durante un tiempo.</li>
<li>Sin embargo, las versiones más modernas de JavaScript sí han implementado <strong>clases</strong>.</li>
<li>En <strong>programación orientada a objetos (POO) en JavaScript,</strong>  se organiza el código alrededor de <strong>objetos</strong>, los cuales son <strong>instancias de clases</strong>.</li>
</ul>
<p><strong>OBJETOS</strong>:  contienen:<br>
- datos (<strong>propiedades</strong>)<br>
- funciones (<strong>métodos</strong>) que operan sobre estos datos</p>
<p>JavaScript, aunque basado en <strong>prototipos</strong>, permite un estilo de programación orientado a objetos mediante el uso de <strong>clases</strong> (introducidas en ES6) y <strong>objetos</strong></p>
<p>Comencemos con <strong>una analogía</strong>. Crear un <strong>plano de una casa</strong>:</p>
<div>  
<img src="planoCasa.png" width="58%" alt="plano de una Casa">  
 <img src="casaEstruct.png" width="35%" alt="estructura de una Casa">  
</div>
<ul>
<li>cuantas plantas tiene</li>
<li>tabiques, para cada dormitorio</li>
<li>ubicaciones de puertas</li>
<li>ubicación de las ventanas</li>
<li>donde van los enchufes de luz…</li>
</ul>
<p>Nos hacemos una idea.  <strong>Esto NO es una casa</strong>. Es la <strong>estructura</strong>.</p>
<p>Esta <strong>estructura</strong> la podemos asociar con lo que, en Javascript, corresponde a una <strong>clase</strong>.<br>
<br><br>
<strong>UNA CLASE:</strong></p>
<ul>
<li><strong>Una clase</strong> es simplemente una lista de definiciones que indican exactamente cómo debería comportarse.</li>
<li><strong>Una clase</strong> numerará <strong>atributos</strong> para <strong>describir</strong> lo que se supone que debe hacer la clase y su <strong>comportamiento</strong>.<br>
<br></li>
</ul>
<h4 id="ejemplo-imaginemos-la-clase-usuario">EJEMPLO: Imaginemos la clase <code>Usuario</code>:</h4>
<ul>
<li>CLASE: Cada vez que <strong>un nuevo usuario</strong> accede un sitio web y se registra, el programa <strong>revisará la clase <code>Usuario</code> y verá esa esa estructura</strong>. Es lo mismo que decir que “es importante ver <strong>cómo debería comportarse ese usuario</strong>”, para pasar luego al siguiente paso.</li>
<li>INSTANCIACIÓN: Es un término complejo. Significa que tomamos ese plano y <strong>creamos con él un objeto real</strong>.</li>
</ul>
<p><em>En nuestro ejemplo:</em></p>
<ul>
<li>tenemos una <strong>clase <code>Usuario</code></strong></li>
<li>con un <strong>nombre</strong> de usuario</li>
<li>y algunas <strong>funciones</strong>,
<ul>
<li>indicar <strong>qué queremos que haga</strong> el usuario después de iniciar sesión,</li>
<li><strong>qué página</strong> queremos ver</li>
<li><strong>qué tipo de atributos</strong> queremos que estén disponibles para el usuario, <strong>como obtener su apellido o algo similar</strong>, que su aplicación necesita. (<strong>datos</strong>)</li>
</ul>
</li>
</ul>
<br>
<p><em>El programa haría lo siguiente:</em></p>
<ol>
<li>
<p><strong>examinar</strong> el plano, en este caso, la estructura</p>
</li>
<li>
<p><strong>crear e instanciar un objeto con ella</strong>, que será el objeto con el que trabajarán. Este es el momento en el que deja de ser un simple plano para convertirse <strong>en algo terminado</strong>, en ese <strong>objeto real</strong>.  Hemos creado un “ejemplar” de algo, basado en la estructura anterior.</p>
</li>
<li>
<p>Luego puedo <strong>hacer otro objeto</strong> con otro nombre y <strong>basarlo en la misma plantilla</strong> o estructura. Serían dos objetos distintos que tienen una misma estructura.</p>
</li>
</ol>
<br>
<h3 id="constructor-de-una-clase">CONSTRUCTOR de una clase</h3>
<p><strong>Durante muchos años</strong> JavasScript <strong>no tenía</strong> técnicas de OOP ( Object-Oriented Programming ) o de <strong>programación orientada a objetos</strong>.  Había que crear procedimientos alternativos para conseguir lo que se necesitaba, y una de ellas era la utilización <strong>funciones a modo de clases.</strong></p>
<p><strong>Un constructor</strong>  es una función especial  (<strong>palabra clave reservada para las clases</strong>) que:</p>
<ul>
<li>se utiliza para <strong>crear e inicializar objetos</strong>.</li>
<li>se encarga de <strong>definir las propiedades iniciales de un objeto</strong> al momento de su creación.  Estas <strong>propiedades</strong>:
<ul>
<li>Son <strong>variables</strong> que se definen dentro de la función constructora <strong>para almacenar datos sobre el objeto</strong>.</li>
<li>Se <strong>acceden y modifican</strong> utilizando la palabra clave  <strong><code>this</code>  seguida del nombre de la propiedad</strong>.</li>
</ul>
</li>
<li>Un constructor <strong>se invoca con</strong> la palabra clave  <strong><code>new</code></strong>.<br>
<br></li>
</ul>
<h4 id="sintaxis-básica-del-contructor">SINTAXIS BÁSICA DEL CONTRUCTOR</h4>
<div align="center">
<img src="constructorSintaxis.png" alt="sintaxis constructor">
</div>
<br>
<h4 id="algunos-conceptos-clave-del-constructor">ALGUNOS CONCEPTOS CLAVE DEL CONSTRUCTOR</h4>
<ul>
<li>Cada vez que se crea una clase, el nombre de <strong>constructor</strong> es una <strong>palabra clave reservada para las clases</strong>,  específicamente utilizada dentro de ellas.</li>
<li><strong>No siempre están</strong> en todas las clases, pero muy habitualmente sí</li>
<li>Tareas: <strong>fijar</strong> valores, <strong>llamar</strong> a otras funciones, etc.</li>
<li>El constructor <strong>define el método</strong> que se ejecuta <strong>al crear</strong> una nueva <strong>instancia</strong> de la clase.</li>
<li>Una <strong>clase</strong> en sí <strong>no ejecuta nada</strong> (son como hemos dicho un conjunto de reglas y pautas para la ejecución)</li>
<li>Es <strong>la instancia</strong>, la que <strong>ejecuta todos los procesos</strong> que queramos cada vez que <strong>creemos un nuevo objeto</strong> (lo haremos con la palabra clave <strong><code>new</code></strong> ).<br>
.<br>
<br></li>
</ul>
<h4 id="ejemplo-de-clase-y-de-instancia">EJEMPLO DE CLASE Y DE INSTANCIA:</h4>
<ul>
<li>Haremos uso de la  <strong>deconstrucción</strong> (anteriormente explicada), y pasaremos un nombre, o sea, <code>name</code>, <strong>como objeto</strong></li>
</ul>
<div align="center">
<img src="claseConstructor.png" width="85%" alt="clase e instancia">
</div>
<br>
<ul>
<li>
<p>El hecho de crear una <strong>instancia</strong> nos dirige automáticamente <strong>al <code>constructor</code>.</strong></p>
</li>
<li>
<p>En <strong><code>constructor ({ name })</code></strong>, aquí   <strong><code>name</code></strong>  mapeará a lo que se pase cuando creemos un nuevo Instructor: <strong><code>new Instructor</code></strong>). - A continuación queremos hacer algo con este <strong><code>name</code></strong>:</p>
</li>
<li>
<p><strong>Añadimos <code>name</code>  a la clase</strong> para que forme parte de ella, y la forma de que esto funcione es a través de la palabra clave <strong><code>this</code></strong>.</p>
</li>
<li>
<p>Al acceder a <strong><code>name</code></strong> mediante <strong><code>this.name</code> estamos añadiendo el atributo <code>name</code></strong> a <strong><code>this.name</code></strong>.</p>
</li>
<li>
<p>Los <strong>colores</strong> aquí muestran perfectamente que son cosas diferentes:</p>
<ul>
<li>los dos <font color="blue"> <strong><code>name</code> en color azul</strong> </font>hacen referencia al <strong>mismo elemento dentro del objeto</strong>, pero el siguiente  <strong><font color="darkred">  <code>name</code> en color rojo</font></strong> en <code>this.name</code> hace referencia <strong>a una instancia de la clase <code>Instructor</code>,</strong> precisamente la instancia que hemos creado asignándola a la variable <code>jon</code>.</li>
<li>En esta instancia en específico, le decimos que <strong>almacene cualquier <code>name</code></strong> (<code>this.name = name</code>) <strong>que sea pasado como parámetro con este objeto.</strong></li>
</ul>
</li>
</ul>
<img src="iconoPrecauc.png" alt="icono de cuidado">
<p><strong>OJO!!</strong> Cuando quiera que el <strong>constructor</strong> tome un <strong>objeto</strong> como argumento, entonces <strong>al instanciar también tenemos que poner un objeto como argumento!!</strong><br>
<br><br>
<br></p>
<h4 id="accediendo-a-la-clave-de-la-instancia">ACCEDIENDO A LA CLAVE DE LA INSTANCIA:</h4>
<p>La variable <code>jon</code> se llama <strong>instancia de la clase Instructor</strong>.  En cuanto al tipo de dato, es <strong>un objeto</strong>. De hecho si hacemos:</p>
<pre class=" language-javascript"><code class="prism  language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jon<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// imprime: Object { name: "Jon Snow"}</span>
</code></pre>
<p>Y precisamente por ello, podemos acceder al atributo <strong><code>name</code></strong>  mediante la nomenclatura con punto o <strong>dot notation</strong> de los objetos:</p>
<div align="center">
<img src="instancia.png" width="62%" alt="instancia muestra atributo">
</div>
<h4 id="otro-ejemplo">OTRO EJEMPLO:</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">class</span> <span class="token class-name">Coche</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>marca<span class="token punctuation">,</span> modelo<span class="token punctuation">,</span> año<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>marca <span class="token operator">=</span> marca<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>modelo <span class="token operator">=</span> modelo<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>año <span class="token operator">=</span> año<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> miCoche <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coche</span><span class="token punctuation">(</span><span class="token string">'Toyota'</span><span class="token punctuation">,</span> <span class="token string">'Corolla'</span><span class="token punctuation">,</span> <span class="token number">2020</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>miCoche<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>En este ejemplo:</p>
<ul>
<li>La <strong>clase</strong>  <code>Coche</code>  tiene un <strong>constructor</strong> que toma <strong>tres parámetros</strong>:  <code>marca</code>,  <code>modelo</code>  y  <code>año</code>.</li>
<li>Cuando se crea la <strong>instancia</strong>  <code>miCoche</code>, se pasan los <strong>valores</strong>  <code>'Toyota'</code>,  <code>'Corolla'</code>  y  <code>2020</code>  <strong>al constructor</strong>.</li>
<li>El <strong>constructor asigna estos valores a las propiedades del objeto</strong>, usando  <code>this.marca</code>,  <code>this.modelo</code>  y  <code>this.año</code>.<br>
<br></li>
</ul>
<h2 id="métodos-de-instancia">2. MÉTODOS DE INSTANCIA</h2>
<ul>
<li>
<p>Durante mucho tiempo en JS se ha venido creando <strong>funciones tradicionales en vez de los métodos de instancia</strong>, que son métodos que operan de forma específica sobre la <strong>“instancia” de una clase</strong>.</p>
</li>
<li>
<p>Sin embargo, lo más común en los últimos años es :</p>
<ul>
<li>poder <strong>acceder y modificar los atributos de la instancia en la que se están invocando</strong>,</li>
<li>poder <strong>llamar a otros métodos dentro de la instancia</strong>.</li>
</ul>
</li>
</ul>
<p><strong>Los métodos dentro de una clase</strong> son funciones que están <strong>asociadas a esa clase</strong> y se utilizan para <strong>definir el comportamiento</strong> de los objetos creados a partir de ella.</p>
<ul>
<li>Se <strong>definen dentro del cuerpo de la clase,</strong></li>
<li>Con <strong>la misma sintaxis que las funciones, pero sin la palabra clave</strong> <strong><em>function</em></strong>  para métodos públicos.</li>
<li>Los métodos pueden <strong>acceder a las propiedades de la instancia</strong> actual utilizando <strong><code>this</code></strong>.</li>
</ul>
<br>
<h3 id="ejemplo-1---métodos-de-instancia">EJEMPLO 1 - Métodos de Instancia</h3>
<div align="center">
<img src="metodoInstancia.png" width="75%" alt="método de instancia">
</div>
<br>
<ul>
<li>En el <strong><code>console.log</code></strong> del método de la instancia <strong><code>renderDetails()</code></strong>  necesitamos poner el <strong><code>this</code></strong> en <strong><code>this.name</code></strong>  para poder acceder al valor de <strong><code>name</code></strong> del argumento.</li>
<li>Cuando instanciamos y pasamos los valores entre llaves <code>new Instructor({name: "Jon Snow"}</code>; nos dirige <strong>al contructor.</strong></li>
<li>En la <strong>instancia de método<code>renderDetails()</code> no tenemos acceso este argumento</strong>: sólo lo tiene <strong>el constructor</strong>, así que la única manera de acceder es añadir la palabra clave <strong><code>this</code></strong>  <strong>a los atributos</strong> creados <strong>dentro de los constructores</strong>.<br>
<br><br>
<img src="iconoPrecauc.png" alt="icono de cuidado"></li>
</ul>
<p><strong>OJO!!</strong> No debemos olvidar que PRIMERO debemos INSTANCIAR LA CLASE para convertir la variable a OBJETO. <strong>Nunca podríamos llamar al método de la instancia sin instanciar la clase primero</strong>. De hecho, nos daría <strong>error</strong>.<br>
<br><br>
<br></p>
<h3 id="ejemplo-2---métodos-de-instancia">EJEMPLO 2 - Métodos de Instancia</h3>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">class</span> <span class="token class-name">Coche</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>marca<span class="token punctuation">,</span> modelo<span class="token punctuation">,</span> año <span class="token operator">=</span> <span class="token number">2019</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>marca <span class="token operator">=</span> marca<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>modelo <span class="token operator">=</span> modelo<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>año <span class="token operator">=</span> año<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> miCoche <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coche</span><span class="token punctuation">(</span><span class="token string">'Toyota'</span><span class="token punctuation">,</span> <span class="token string">'Corolla'</span><span class="token punctuation">,</span> <span class="token number">2020</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>miCoche<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Coche { marca: 'Toyota', modelo: 'Corolla', 'año': 2020 }</span>
</code></pre>
<ul>
<li>La <strong>clase</strong>  <code>Coche</code>  tiene un constructor que toma <strong>tres parámetros</strong>:  <code>marca</code>,  <code>modelo</code>  y  <code>año</code>.</li>
<li>Cuando se crea la <strong>instancia</strong>  <code>miCoche</code>, se pasan los valores  <code>'Toyota'</code>,  <code>'Corolla'</code>  y  <code>2020</code>  al constructor.</li>
<li>El <strong>constructor asigna estos valores a las propiedades</strong> del objeto, usando  <code>this.marca</code>,  <code>this.modelo</code>  y  <code>this.año</code>.</li>
<li><strong>Ignora la propiedad</strong> <code>año</code> que el constructor contiene <strong>por defecto</strong>. Ésta, <strong>(<code>'año': 2019</code>)</strong> , solo <strong>se habría imprimido</strong> si al pasar los parámentros en la instancia <strong>no hubiera incluido el valor para <code>'año'</code></strong>, es decir que con:<br>
<code>const miCoche = new Coche('Toyota', 'Corolla');</code><br>
<strong>imprimiría</strong>    <code>//Coche { marca: 'Toyota', modelo: 'Corolla', 'año': 2019 }</code><br>
<br><br>
<br></li>
</ul>
<h2 id="métodos-estáticos">3. MÉTODOS ESTÁTICOS</h2>
<ul>
<li>En JavaScript, los métodos estáticos son aquellos que pertenecen <strong>a la clase en sí misma, no a instancias individuales de la clase.</strong></li>
<li>Esto significa que <strong>se pueden invocar directamente desde la clase,</strong> <strong>sin</strong> necesidad de <strong>crear un objeto</strong> de esa clase.</li>
</ul>
<br>
<h4 id="sintaxis-6">SINTAXIS</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">class</span> <span class="token class-name">MiClase</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">miMetodoEstatico</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Este es un método estático."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>ACCESO AL MÉTODO ESTÁTICO</strong></p>
<pre class=" language-javascript"><code class="prism  language-javascript">miClase<span class="token punctuation">.</span><span class="token function">miMetodoEstatico</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<br>
<h4 id="ejemplo-1---creamos-un-producto-genérico-para-una-empresa">EJEMPLO 1 - Creamos un producto genérico para una empresa</h4>
<pre class=" language-javascript"><code class="prism  language-javascript">    <span class="token keyword">class</span> <span class="token class-name">Producto</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span>nombre<span class="token punctuation">,</span> precio<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>nombre <span class="token operator">=</span> nombre<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>precio <span class="token operator">=</span> precio<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">static</span> <span class="token function">crearProductoPredeterminado</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Producto</span><span class="token punctuation">(</span><span class="token string">"Producto Genérico"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> productoPredeterminado <span class="token operator">=</span> Producto<span class="token punctuation">.</span><span class="token function">crearProductoPredeterminado</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>productoPredeterminado<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
    <span class="token comment">// Devuelve: Producto { nombre: 'Producto Genérico', precio: 0 }</span>
</code></pre>
<ul>
<li>Como vemos, ha podido acceder tanto al <code>nombre</code> como al <code>precio</code>, ya que los métodos estáticos <strong>pueden acceder y manipular propiedades estáticas de la clase.</strong></li>
<li>Se acceden a ellos <strong>a través del nombre de la clase</strong> (aquí <code>Producto</code>).<br>
<br></li>
</ul>
<h4 id="ejemplo-2----cliente-entra-y-dice-hola-método-de-instancia--se-despide-y-dice-adiós-método-estático">EJEMPLO 2 :   Cliente entra y dice “Hola” (método de instancia)  se despide y dice “Adiós” (método estático)</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">class</span> <span class="token class-name">Cliente</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">despedirse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"Adiós"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">entrar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"Hola"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Cliente<span class="token punctuation">.</span><span class="token function">despedirse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (1) Método estático (no requiere instancia): 'Adiós'</span>
Cliente<span class="token punctuation">.</span><span class="token function">entrar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// (2) Uncaught TypeError: Cliente.entrar is not a function</span>

<span class="token keyword">const</span> cliente1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cliente</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// (3) Creamos una instancia</span>

cliente1<span class="token punctuation">.</span><span class="token function">despedirse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// (4) Uncaught TypeError: cliente1.despedirse is not a function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cliente1<span class="token punctuation">.</span><span class="token function">entrar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// (5) Método no estático (requiere instancia): 'Hola'</span>
</code></pre>
<p>(1) Como vemos, el método <strong>estático</strong>  <code>despedirse()</code> se ejecuta<br>
sin problemas accediendo a él con el <strong>nombre de la clase</strong><br>
delante.<br> (2) El método <code>entrar()</code> no es estático - <strong>Necesita un<br>
instancia</strong> para acceder a él. Nos da error.<br> (3) Creamos la<br>
instancia.<br> (4) El método <code>despedirse()</code> es <strong>estático</strong>, la<br>
forma de acceder a él es a través de la <strong>clase</strong>, <strong>no de una<br>
instancia</strong>.<br> (5) El método <code>entrar()</code> no es estático, ya hemos<br>
<strong>creado la instancia y esta vez no nos da error</strong>.</p>
<br>
<h4 id="cuándo-utilizar-los-métodos-estáticos">CUÁNDO UTILIZAR LOS MÉTODOS ESTÁTICOS</h4>
<p>El método estático es útil cuando :<br>
<strong>-</strong> se necesita crear instancias de una clase con cierta lógica de inicialización o <strong>configuración específica</strong></p>
<ul>
<li>
<p><strong>se prefiere evitar el uso de  <code>new</code></strong>  por simplicidad o por otras razones de diseño. Es decir, pueden usarse <strong>para crear instancias de la clase de forma personalizada</strong></p>
</li>
<li>
<p><strong>cuando no necesitemos acceder a propiedades de instancia</strong>: tiene que ver más <strong>con la estructura</strong> y menos con la instancia. Si un método no necesita acceder a datos específicos de un objeto, es <strong>más eficiente</strong> declararlo <strong>como estático.</strong></p>
</li>
<li>
<p>cuando necesitemos <strong>funciones de utilidad:</strong></p>
<ul>
<li>a) <strong>funciones auxiliares</strong> (<em><strong>helper modules</strong></em>). Los métodos “helper” o auxiliares son funciones diseñadas para realizar tareas <strong>específicas y reutilizables, simplificando el código y mejorando la legibilidad</strong>. Estos métodos a menudo se encapsulan en un módulo o clase para <strong>su fácil acceso y mantenimiento</strong></li>
<li>b) propósito general que <strong>no están ligadas a un objeto en particular</strong>, por ejemplo:
<ul>
<li>como métodos para <strong>manipular arrays</strong></li>
<li>realizar <strong>cálculos matemáticos</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Como funciones de fábrica</strong>.-   es una función que <strong>devuelve un objeto</strong> nuevo cada vez que se llama:</p>
<ul>
<li>cuando un <strong>método estático</strong> se utiliza para ello,  <strong>para crear objetos</strong>, y se convierte en una <strong>función fábrica</strong></li>
<li><strong>no requieren el uso de  <code>new</code>,</strong> lo que permite <strong>crear objetos de manera más flexible</strong>.</li>
</ul>
</li>
</ul>
<br>
<img src="iconoPrecauc.png" alt="icono de cuidado">
<p><strong>OJO!!</strong> Cuando estemos creando una aplicación y estemos pensando en utilizar un método estático, primero deberíamos preguntarnos en profundidad:</p>
<div align="center">
<img src="pregunta.png" width="40%" alt="pregunta método estático">
</div>
<br>
<br>
<div align="center">  Ya que hay LÍNEA MUY FINA entre:  </div>
<br>
<div align="center">
<img src="disyuntiva.png" width="60%" alt="disyuntiva">
</div>
<br>
<div align="center">  y en la PROGRAMACIÓN ORIENTADA A OBJETOS  existe el llamado algo llamado:  </div>
<br>
<br>
<div align="center">
<img src="PRU.png" width="40%" alt="principioresp.única">
</div>
<p>El <strong>Principio de Responsabilidad Única</strong> (PRU) en JavaScript  significa que <strong>cada clase</strong>  (función, etc.) debería <strong>tener solo una tarea o responsabilidad</strong> claramente definida, y <strong>no intentar abarcar múltiples tareas</strong> no relacionadas.</p>
<br>
 <br>
<hr>
<h1 id="¿qué-es-una-promesa-en-js">7. ¿Qué es una promesa en JS?</h1>
<ul>
<li>
<p>Para entender el concepto de <strong>Promesa</strong> o <strong>Promise</strong> en líneas generales, una de las formas más comunes de trabajar con <strong>Promises</strong> o <strong>Promesas</strong> es cuando te comunicas con <strong>APIs</strong>.</p>
</li>
<li>
<p>Por ejemplo me conecto a una <strong>API de <em>Twitter</em></strong>, para poder obtener todas las <strong>publicaciones</strong>. Así que llamo a una <strong>URL (un endpoint</strong>) y las recibo.</p>
</li>
</ul>
<br>
<img src="decepcion.png" align="right" width="90">   Y qué pasaría en mi aplicación SI TWITTER SE CAE? Si un usuario va a la página, pero solo podría ver algo que es parte de la memoria intermedia (bufer) como unos puntos suspensivas "………………… " o algo así:   sin duda, UNA EXPERIENCIA NO AGRADABLE PARA CUALQUIER USUARIO.
<br>
<br>
<br>
<img src="alegria.png" align="left" width="90">   Lo que una  PROMESA nos permite es llamar a TWITTER, mostrar nuestra página,  y CUANDO LAS PUBLICACIONES FINALMENTE LLEGUEN DE LA API, QUE LAS MUESTRE.
<br>
<br>
<br>
<br>
<ul>
<li>
<p>Una <strong>promesa</strong> ejecuta realmente una tarea que <strong>no queremos que ocurra en tiempo real</strong>; podemos desarrollar cualquier funcionalidad nueva en la que sea conveniente <strong>que no se procese inmediatamente</strong>, como una <strong>consulta</strong> a una base de datos o <strong>API</strong> externa.</p>
</li>
<li>
<p>Esto es algo que tiene muy positivo JavaScript: <strong>su capacidad para trabajar de forma asíncrona.</strong> Esto significa que puedes hacer tareas como ésta de llamar servicios externos y usar APIs, y poder tomar y en realidad, <strong>elegir  qué elementos</strong> de tu página o en tu aplicación <strong>se cargarán directamente, y cuáles pueden tardar más tiempo</strong>.</p>
<ul>
<li>Efectivamente, algo muy a favor de <strong>Javascript</strong> es que <strong>trabaja directamente con la experiencia del usuario</strong>. No sería deseable que el usuario se quede esperando durante un tiempo hasta que finalmente los datos se carguen.</li>
</ul>
</li>
<li>
<p><strong>La naturaleza de JavaScript es la comunicación con servicios externos</strong>, como bases de datos, <strong>APIs backend</strong> ( l<em>as <em><strong>APIs backend</strong></em> se ejecutan en el servidor y gestionan la aplicación y la interacción con la base de datos; en esencia, son el motor que impulsa la funcionalidad visible en el frontend</em> ) o cualquier otro servicio fuera de la aplicación, <strong>como las diferentes plataformas</strong> de JavaScript  <em><strong>React, Angular y Vue</strong></em>; JavaScript <strong>recibe los datos como resultado de esta comunicación con dichos servicios externos.</strong></p>
</li>
<li>
<p>La utilización de herramientas como las <strong>promesas</strong> son el pilar central de <strong>podamos confiar</strong> en que el proceso se desarrollará <strong>tan fluidamente como sea posible</strong>.<br>
<br></p>
</li>
</ul>
<h4 id="convención-común">CONVENCIÓN COMÚN:</h4>
<p>Los argumentos de la función <code>Promise()</code> son <code>resolve</code> y <code>reject</code>.  Antes era <code>success</code> y  <code>failure</code>, pero ahora lo más extendido son los primeros.<br>
<br><br>
Una <strong>promesa</strong> o bien:</p>
<ul>
<li>funciona y <strong>resuelve</strong> ese código. Por ejemplo, algún tipo de respuesta con <strong>éxito</strong> -si nos comunicamos con una API, nos devolverá los datos de esa API y podremos manejarlos; o</li>
<li><strong>no funciona</strong> y por lo tanto devuelve algún tipo de <strong>error</strong>.</li>
</ul>
<br>
<h4 id="proceso-de-codificación-de-las-promesas">PROCESO DE CODIFICACIÓN DE LAS PROMESAS:</h4>
<ul>
<li>
<p>En general, con las <strong>funciones, clases</strong>, etc <strong>no dedicamos</strong> mucho <strong>tiempo</strong> pensando en las <strong>eventualidades</strong> negativas de que ocurriera <strong>errores</strong>.</p>
</li>
<li>
<p>Sin embargo una <strong>promesa</strong> te obliga a crear un sistema entero dividido prácticamente <strong>50/50</strong> :</p>
<ul>
<li><strong>50%</strong> del tiempo lo dedicamos a codificar sobre situaciones en las que el proceso <strong>se resuelve con éxito,</strong></li>
<li>y el otro <strong>50%</strong> lo pasamos creando los tipos de proceso que ocurrirán <strong>si se produce un error.</strong></li>
</ul>
</li>
</ul>
<br> 
<h4 id="sintaxis-básica-de-una-promesa.">SINTAXIS básica de una promesa.</h4>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> promesa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  

<span class="token comment">// Aquí se realiza la operación asíncrona :</span>
<span class="token comment">// Si la operación es exitosa, se llama a resolve(valor) </span>
<span class="token comment">// Si ocurre un error, se llama a reject(error)  </span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<br>
<ul>
<li>
<p><strong><code>new Promise((resolve, reject) =&gt; { ... })</code>:</strong></p>
<p>Crea una <strong>nueva instancia de promesa</strong>. El constructor <code>new</code>toma una función con dos parámetros:  <code>resolve</code>  y  <code>reject</code>.<br>
<br><br>
<br></p>
</li>
</ul>
<h4 id="buena-práctica">BUENA PRÁCTICA</h4>
<p>Una buena práctica es añadir la palabra <strong>“Promise”</strong> <strong>al nombre de la variable</strong>, para identificar el propósito en futuros accesos al programa. Al ser así de <strong>descriptivo</strong>, facilitará cualquier interpretación y/o modificación del mismo: por ejemplo <strong><code>postsPromise = fetch("https:// aaa.bbbbbbb.com/posts")</code></strong>  si tratamos de obtener las publicaciones o “<em><strong>posts</strong></em>” de una página web (p.ej. <em>Twitter</em>).<br>
<br><br>
<br></p>
<h3 id="proceso-básico-promesa">Proceso básico promesa</h3>
<div align="center">
<img src="basicoPromesa.png" width="55%" alt="proceso básico promesa">
</div>
<br>
<p><strong>EXPLICACIÓN:</strong></p>
<ul>
<li>
<p><strong><code>resolve(valor)</code>:</strong></p>
<ul>
<li>
<p>Esta función se usa para indicar que la operación asíncrona ha terminado <strong>con éxito.</strong></p>
</li>
<li>
<p><code>valor</code>  <strong>es el resultado de la operación, que se pasará al siguiente bloque  <code>then()</code></strong>  en la cadena de promesas.</p>
</li>
<li>
<p>Si  <code>valor</code>  es otra promesa, se “aplanará” (pondrá en una sola capa todas las promesas anidadas) y su resultado se usará como el resultado de esta promesa.</p>
<ul>
<li><strong><code>then()</code>:</strong>  se usa para <strong>encadenar funciones a una promesa, permitiendo manejar el resultado exitoso</strong> de una operación asíncrona. Cuando la promesa se resuelve, la función  <code>then()</code>  se ejecuta con el valor de la promesa, y <strong>si devuelve otra promesa, el encadenamiento continúa con esa nueva promesa</strong>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>reject(error)</code>:</strong></p>
<ul>
<li>Esta función se usa para indicar que la operación asíncrona <strong>ha fallado.</strong></li>
<li><strong><code>error</code></strong>  es una <strong>descripción del error</strong>, que puede ser cualquier tipo de valor, aunque <strong>se recomienda usar un objeto  <code>Error</code>  para facilitar la depuración</strong>.</li>
<li>El error se pasará al bloque  <code>catch()</code>  o al siguiente  <code>then()</code>  con un segundo argumento (el manejador de rechazo) en la cadena de promesas.
<ul>
<li>El método  <strong><code>catch()</code></strong> se usa para <strong>manejar errores o casos de rechazo en una promesa</strong>. Se ejecuta cuando la promesa asociada es rechazada, permitiendo ejecutar código específico para <strong>manejar el error</strong>, <strong>como mostrar un mensaje o realizar alguna acción correctiva.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<h3 id="secuencia-del-proceso-de-creación-de-una-promesa--a-través-de-un-ejemplo">Secuencia del proceso de creación de una promesa,  a través de un EJEMPLO:</h3>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">let</span> sleepyGreeting <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Hello....'</span><span class="token punctuation">)</span>                <span class="token comment">// ponemos ….porque es “sleepy” </span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			     <span class="token comment">// 2 seg (2000milseg). Después de ese tiempo retorna el Hello.</span>

  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">'Too sleepy...'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//Error()con mayúscula, ya que es un módulo de JS</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

sleepyGreeting
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
  <br>
<ol>
<li>
<p>Creamos una <strong>variable</strong> que llamamos <code>sleepyGreeting</code>,</p>
</li>
<li>
<p><strong>Asignamos a la variable</strong> la creación de una <strong>nueva promesa</strong> new Promise().</p>
</li>
<li>
<p><strong>Promise()</strong>, toma <strong>como argumento una función</strong>. Como primer argumento (aquí no ponemos los opcionales) toma <strong>una función</strong>, por ello se llama  <strong>callback</strong>.</p>
</li>
<li>
<p><strong>Esta función callback</strong> (que en este caso sera función flecha) <strong>tiene dos argumentos</strong>:<code>resolve</code> y <code>reject</code>, mencionada convención común, que es particular de los métodos correspondientes de <code>resolve()</code> y <code>reject()</code>.</p>
</li>
<li>
<p>Creamos <strong>dos métodos de <code>setTimeout()</code></strong>,  con el fin de poner <strong>temporizadores</strong>.  Generalmente, <strong>cuando trabajas con promesas</strong>,  tu expectativa es que aquello que quieres obtener, <strong>no lo obtengas de forma inmediata</strong>. <strong>Puede tardar bien milisegundos o unos segundos.</strong>    Este temporizador nos permite controlar esto, e incluso <strong>imitar lo que obtendríamos si llamamos a una API</strong> o algo parecido.   Esta función toma dos argumentos:<br>
-		<em>una función</em>  a ejecutar &nbsp; <strong><code>resolve(valor)</code></strong> y <strong><code>reject(mensaje)</code></strong><br>
-		<em>retraso o “delay”</em>:&nbsp; &nbsp; <strong>el tiempo de espera en milisegundos</strong> (2 segundos en este caso).</p>
</li>
<li>
<p>Finalmente, <strong>llamamos a la función.</strong> Por CONVENCIÓN COMÚN, lo hacemos con la <strong>sintaxis</strong> de:</p>
<ul>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> <strong>Varias líneas</strong></p>
</li>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> <strong>Indentación</strong> antes de poner los métodos <strong><code>then()</code> y <code>catch()</code></strong><br>
<br></p>
</li>
</ul>
</li>
</ol>
<h3 id="llamada-a-la-función-métodos-bigthen-bigy--bigcatchbig-del-ejemplo-anterior-">Llamada a la función: métodos <big><code>then()</code> </big>y  <big><code>catch()</code></big> del EJEMPLO anterior :</h3>
<ol>
<li>
<p><code>data</code> es convención común para referirse a los datos recibidos; para el almacenamiento de los datos.<br>
Significa que cuando llamamos a la función (<code>sleepyGreeting()</code>) y obtengamos la respuesta:<br>
<strong>"entonces</strong> (en inglés, “then”), <strong>haz esto, esto y esto"</strong>  (todo lo que ponga despues del <code>then()</code>) .</p>
<p>En nuestro caso, sería nuestro string <font color="green"><strong>“Hello……”.</strong></font>. En otros ejemplos, correspondería a las <strong>peticiones de publicación JSON, o tweets, o lo que quiera que haga cuando estemos llamando.</strong><br>
<br></p>
</li>
<li>
<p><strong><code>catch(err =&gt; { console.error(err); })</code></strong>  es un método que se utiliza para manejar errores asíncronos, específicamente en el <strong>contexto de promesas</strong>.   En otras palabras, es una forma de <strong>asegurar que si una operación asíncrona falla, el error se capture y se muestre en la consola</strong>, permitiendo a los desarrolladores responder adecuadamente. Analicemos cada parte:</p>
<ul>
<li>
<p><strong><code>.catch()</code>:</strong></p>
<p>Este es el método que se usa para <strong>capturar errores</strong>. Se aplica a una <strong>promesa</strong> y se ejecuta <strong>cuando la promesa es rechazada (reject)</strong>, es decir, cuando ocurre un error durante la operación asíncrona.</p>
</li>
<li>
<p><strong><code>err =&gt; { ... }</code>:</strong></p>
<p>Esta es una <strong>función flecha</strong> (arrow function) que actúa como el <strong>manejador de errores.</strong></p>
<ul>
<li><strong><code>err</code>:</strong> Es el parámetro de la función, que <strong>representa el objeto de error</strong> que se ha producido. Este objeto contiene <strong>información sobre el error, como su tipo y mensaje</strong>.</li>
<li><strong><code>{ console.error(err); }</code>:</strong>  Dentro de la función,  <strong><code>console.error(err)</code></strong>  se utiliza para <strong>registrar el error en la consola del navegador</strong> o del entorno donde se ejecuta el código. Esto ayuda a los desarrolladores a <strong>identificar y depurar problemas.</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<br>
<h2 id="método-bigfetchbig-para--solicitudes-de-red">Método <big><code>fetch()</code></big> para  solicitudes de red</h2>
<p>El método  <code>fetch()</code>  :</p>
<ul>
<li>comienza el proceso de <strong>capturar un recurso de un servidor</strong>.</li>
<li>se utiliza para realizar solicitudes de red y obtener recursos de forma <strong>asíncrona</strong>, <strong>como datos JSON, archivos, imágenes, etc.</strong></li>
<li>esta forma moderna y flexible de <strong>realizar peticiones HTTP y</strong> obtener respuestas del servidor tiene una <strong>sintaxis limpia y fácil de usar.</strong></li>
</ul>
<h4 id="sintaxis-7">SINTAXIS:</h4>
<pre class=" language-js"><code class="prism  language-js"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'&lt;Tu URL&gt;'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// Manejamos la respuesta de la petición aqui</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// Si hay un error en la petición, lo manejamos aqui </span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<ul>
<li>
<p>Acepta <strong>dos parámetros:</strong></p>
<ol>
<li><strong>La URL a la que enviar la petición</strong> (este es un parámetro obligatorio).</li>
<li><strong>Las opciones a configurar en la petición.</strong> Aquí se puede configurar el método de solicitud aquí (este es un <strong>parámetro opcional</strong>).</li>
</ol>
</li>
<li>
<p><strong><code>fetch()</code>  devuelve una promesa</strong> que se resuelve al objeto  <code>Response</code>, el cual contiene información sobre la respuesta, como el estado, encabezados y el cuerpo de la respuesta. Es decir, representa la respuesta a la solicitud realizada.  Y dado que se trata de una <strong>promesa</strong>, necesitamos agregar los métodos  <strong><code>.then()</code>  y  <code>.catch()</code>.</strong></p>
</li>
<li>
<p>CONVENCIÓN COMÚN : la respuesta con los datos se suele representar, por convención común sobre todo con dos denominaciones:</p>
<ul>
<li><code>response</code></li>
<li><code>data</code></li>
</ul>
</li>
<li>
<p>Si la solicitud devuelve un error, se ejecutará <strong>el método  <code>catch()</code></strong>:  éste  se puede omitir en Fetch API.<br>
<strong>Se usa solo</strong> cuando <code>fetch()</code> no puede realizar una solicitud a la API, como por ejemplo <strong>si no hay conexión de red o no se encuentra la URL</strong>.</p>
</li>
<li>
<p>Se pueden utilizar métodos como <strong><code>json()</code>,  <code>text()</code>,</strong> etc., para extraer los datos de <strong>la respuesta en diferentes formato</strong>.</p>
</li>
</ul>
<br>
<h4 id="ejemplo-1---fetch---convirtiendo-a-datos-json-y-listando-todos-los-recursos">EJEMPLO 1 - <code>fetch()</code> - Convirtiendo a datos <em>json</em> y listando todos los recursos</h4>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">const</span> postsPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://jsonplaceholder.typicode.com/posts'</span><span class="token punctuation">)</span>

postsPromise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=&gt;</span> data<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// este "data" ya está convertido a json</span>
</code></pre>
<p>Y esta impresión será algo similar a esto:<br>
<br></p>
<div align="center">
<img src="json.png" alt="datos json">
</div>
<br>
<br>
<p>No se visualiza bien, pero como son datos <strong>JSON</strong>, y vemos un objeto, un <strong>array</strong> llamado    <code>posts</code>  conteniendo muchos datos, lógicamente en forma de pares  <strong>clave:valor</strong>. Vemos muchas <strong>claves repetidas</strong> como: <code>title</code>, <code>content</code>, <code>created_at</code> , con sus respectivos valores.<br>
<br></p>
<h4 id="ejemplo-2----fetch---utilizando-el-bucle-foreach">EJEMPLO 2  - <code>fetch()</code> - Utilizando el bucle <code>forEach()</code></h4>
<pre class=" language-js"><code class="prism  language-js">
<span class="token keyword">const</span> postsPromise_2 <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://jsonplaceholder.typicode.com/posts'</span><span class="token punctuation">)</span>

postsPromise_2
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=&gt;</span> data<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>             
      data<span class="token punctuation">.</span>posts<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">//(1*)</span>
         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//(2*)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// Manejar errores en la solicitud</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Error:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>(1*) Iteramos sobre el objeto que nos interesa, que en este caso es  <code>posts</code>, a través del bucle <code>forEach()</code> (que está tomando como argumento una función flecha).</p>
<p>(2*)  En esa iteración solo nos interesa uno de las claves: <code>title</code>, por lo que extraerá todos los valores para cada una de estas claves <code>title</code>repetidas. Se visualizaría algo así:<br>
<br></p>
<div align="center">
<img src="titles.png" width="45%" alt="títulos de los posts">
</div>
<br>
<br>
<p>En este caso <strong>no ha dado error</strong>, por eso <strong>no ha tenido que ejecutar el <code>catch()</code></strong>, pero hay muchas veces que puede hacerlo.</p>
<ul>
<li>Por ejemplo, muy típico es no tener en cuenta la “s” final de la url <code>https: //.......</code> ; o bien una API con <em>https</em> o <em>http</em> que esté utilizando un <strong>sistema completamente seguro</strong>.</li>
</ul>
<p>Y es que, efectivamente, si intentamos capturar este tipo de URL o  <strong>endpoint API</strong> y son sitios web no seguros, hay mucha probabilidad de que estemos trayendo diversos <strong>elementos a tu propia aplicación que no son seguros</strong>. Por ello, <strong>JavaScript lo bloqueará</strong> y nos imprimirá este <strong>error</strong>  al ejecutar la función <code>catch()</code> .</p>
<br>
<div align="center">
<img src="error.png" alt="error, catch()">
</div>
<br>
<h2 id="agrupar--promesas">Agrupar  promesas</h2>
<p>En JavaScript, cuando tenemos <strong>promesas</strong> 	que son muy <strong>parecidas</strong>, las podemos agrupar y gestionar <strong>para tratarlas igual</strong>. Se pueden utilizar dos métodos:   <code>Promise.all()</code>, y  <code>Promise.allSettled()</code> . Esto se ve mucho en <strong>páginas web</strong> y <strong>aplicaciones de móvil</strong>.<br>
<br><br>
<br></p>
<h3 id="el-método-bigpromise.allbig">1.  El método <big><code>Promise.all()</code></big></h3>
<br>
<h4 id="sintaxis-8">SINTAXIS</h4>
<pre class=" language-js"><code class="prism  language-js">Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
</code></pre>
<br>
<h4 id="proceso">PROCESO</h4>
<ol>
<li>Es un método que toma como <strong>entrada un iterable de promesas</strong> que toma  y <strong>devuelve una sola promesa</strong>.</li>
<li>Esta promesa se cumple <strong>cuando se cumplen todas las promesas</strong> de esa entrada (incluso cuando se pase un iterable vacío).</li>
<li>Se <strong>rechazará  en el momento en el que se rechace cualquiera de las promesas</strong> del iterable de entrada,  <strong>devolviendo</strong> la razón de este <strong>primer rechazo</strong>.</li>
</ol>
<br>
<h4 id="ejemplo--promise.all">EJEMPLO  <code>Promise.all()</code></h4>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">const</span> promesa1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> promesa2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> promesa3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promesa1<span class="token punctuation">,</span> promesa2<span class="token punctuation">,</span> promesa3<span class="token punctuation">]</span><span class="token punctuation">)</span>  
	<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resultados<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>resultados<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>  
	<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>
<p>En este ejemplo,  <code>Promise.all()</code>  espera a que <strong>las tres</strong> promesas <strong>se resuelvan</strong>.</p>
</li>
<li>
<p>Una vez que todas se resuelven, el método  <strong><code>then()</code>  se ejecuta</strong>, <strong>pasando un array con los resultados de cada promesa</strong> en el mismo orden en que fueron pasadas a  <code>Promise.all()</code>.</p>
</li>
<li>
<p><strong>Si alguna</strong> de las promesas <strong>se rechazara, el  <code>catch()</code>  se ejecutaría,</strong> mostrando el error.</p>
</li>
</ul>
<br>
<br>
<h3 id="el-método-bigpromise.allsettledbig">2.   El método <big><code>Promise.allSettled()</code></big></h3>
<br>
<h4 id="sintaxis-9">SINTAXIS</h4>
<pre class=" language-js"><code class="prism  language-js">Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
</code></pre>
<br>
<h4 id="proceso-1">PROCESO</h4>
<ul>
<li>
<p>Esta es una alternativa para trabajar con promesas agrupadas.</p>
</li>
<li>
<p>Se comporta de manera similar a  <code>Promise.all()</code>, pero a diferencia de este, <strong>no se detiene ante el primer rechazo</strong>.</p>
</li>
<li>
<p>En vez de ello, <strong>espera a</strong>  que <strong>todas</strong> las promesas del array se resuelvan o rechacen, <strong>devolviendo un array de objetos que indican el estado de cada promesa (resuelta o rechazada)</strong> y su valor o razón de rechazo.<br>
<br></p>
</li>
</ul>
<h4 id="ejemplo--promise.allsettled">EJEMPLO  <code>Promise.allSettled()</code></h4>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">const</span> promesa1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> promesa2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> promesa3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promesa1<span class="token punctuation">,</span> promesa2<span class="token punctuation">,</span> promesa3<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resultados<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>resultados<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*
    [
      { status: 'fulfilled', value: 1 },
      { status: 'rejected', reason: Error: Error },
      { status: 'fulfilled', value: 3 }
    ]
    */</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>
<p>En este ejemplo,  <code>Promise.allSettled()</code>  devuelve un array con los resultados de cada promesa, <strong>incluso aunque una de ellas se haya rechazado.</strong></p>
</li>
<li>
<p>Esto permite <strong>gestionar de forma más flexible</strong> los casos en los que algunas promesas pueden fallar <strong>sin detener el proceso completo</strong>.<br>
<br><br>
<br></p>
</li>
</ul>
<br>
<hr>
<h1 id="¿qué-hacen-async-y-await-por-nosotros">8. ¿Qué hacen async y await por nosotros?</h1>
<p>Una de las mayores <strong>ventajas</strong> de trabajar en JavaScript cuando comparamos con versiones anteriores son los procesos <code>async</code> y <code>await</code>.</p>
<h2 id="historia-de-los-procesos-async---await.">HISTORIA DE LOS PROCESOS <code>async</code> - <code>await</code>.</h2>
<p>Javascript es un programa <strong>sincrónico y monohilo por naturaleza</strong>. Esto significa que las tareas se procesan en el <strong>orden</strong> en el que fueron escritas.</p>
<ul>
<li>Si una función tomaba <strong>demasiado tiempo</strong> en completarse, <strong>bloqueaba la ejecución de otras funciones</strong> hasta que esta función no se hubiera terminado.</li>
<li>Este comportamiento, en un entorno como un <strong>navegador o un servidor con Node.js</strong> no es buena idea, ya que
<ul>
<li>puede generar tiempos de espera largos</li>
<li>e interfaces de usuario bloqueados.</li>
</ul>
</li>
</ul>
<h2 id="event-loop">0. EVENT LOOP</h2>
<p><strong>Para resolver</strong> este comportamiento sincrónico, JavaScript utilizaba las <strong>tareas asincrónicas o “temporizadores”</strong>, a través del método <code>setTimeout()</code>, que se ejecuta <strong>en segundo plano y no afecta a la resolución de las demás tareas</strong>.</p>
<br>
<div align="center">
<img src="eventLoop.png" width="55%" alt="event Loop">
</div>
<br>
<p>Un <strong>event loop</strong> o bucle de eventos es un  mecanismo que <strong>permite la ejecución asíncrona de tareas</strong> manteniendo la capacidad de respuesta del programa. Opera constantemente, monitoreando la cola de tareas y la pila de llamadas para <strong>determinar cuándo y cómo ejecutar el código pendiente</strong>.</p>
<br>
<h4 id="ejemplo-una-solicitud-de-red-–-tarea-lenta-necesita-2-segundos">EJEMPLO: una solicitud de red – TAREA LENTA, necesita 2 segundos:</h4>
<pre class=" language-js"><code class="prism  language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Primero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Segundo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Se ejecutará después de 2 segundos</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Tercero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


Esto imprime<span class="token punctuation">:</span>
<span class="token comment">// Primero</span>
<span class="token comment">// Tercero</span>
<span class="token comment">// Segundo (imprimiría esto después de los 2 segundos </span>
<span class="token comment">//           que tarda esta tarea en ejecutarse)</span>
</code></pre>
<ul>
<li>El <code>setTimeout()</code> ha hecho que esta tarea asincrónica <strong>no bloquee el resto de tareas</strong>, que se han ejecutado antes sin problema.<br>
<br></li>
</ul>
<p>Este tipo de proceso o <strong>Event Loop</strong>, pues, suponía un paso en la dirección correcta. En este punto, <strong>se desarrolló la faceta asíncrona de JavaScript</strong>: entraron a formar parte progresivamente:</p>
<ul>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> las funciones <strong>callback</strong></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled="">  las <strong>promesas</strong></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled="">  y finalmente, las funciones <big><strong><code>async</code></strong></big> -  <big> <strong><code>await</code></strong></big></li>
</ul>
<br>
<h2 id="funciones--callback--y-el-llamado-callback-hell">1. FUNCIONES  <em>CALLBACK</em>  Y EL LLAMADO “<em>CALLBACK HELL</em>”</h2>
<ul>
<li>Las funciones callback <strong>son funciones que se pasan como argumento de otras funciones</strong> para que sean ejecutadas en algún momento dentro de la ejecución de la función principal.</li>
<li>Constituyeron <strong>la primera forma de manejar asincronismo</strong> en Javascript.<br>
<br></li>
</ul>
<h4 id="ejemplo-de-función-callback">EJEMPLO de función <em>callback</em>:</h4>
<pre class=" language-js"><code class="prism  language-js"> <span class="token keyword">function</span> <span class="token function">tareaAsincrona</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Simula una tarea que tarda un tiempo en completarse</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> resultado <span class="token operator">=</span> <span class="token string">"La tarea asíncrona ha finalizado"</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>resultado<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Llama a la func.callback con el rdo.</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Espera 2 segundos</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">miCallback</span><span class="token punctuation">(</span>resultado<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>resultado<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Imprime el rdo. de la tarea asíncrona</span>
<span class="token punctuation">}</span>

<span class="token function">tareaAsincrona</span><span class="token punctuation">(</span>miCallback<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Llama a la función tareaAsincrona, </span>
							<span class="token comment">//pasando miCallback como callback</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"La ejecución continúa..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Se imprime ANTES </span>
									<span class="token comment">//	de ejecutarse el callback</span>
</code></pre>
<ul>
<li>En este código asíncrono, donde cada operación <strong>depende del resultado de la anterior, generaba una estructura en forma de pirámide</strong>. Por ejemplo, no podías realizar la tarea de “hacer llamadas a la API”, <strong>hasta que no hubieras realizado las tareas que están por encima de ella.</strong></li>
<li>Tenías que <strong>codificar cada posible proceso que piensas que pudiera ocurrir</strong> para asegurarte de que no ocurriera demasiado temprano o en un orden que no interese. <strong>Debías tener muy claro la secuencia específica, y codificar eso</strong>.</li>
</ul>
<br>
<p>Llegó lo que se hizo famoso como <strong>callback hell</strong> o infierno de callbacks, lo cual no hizo sino añadir <strong>más hándicaps</strong> a las <em><strong>callback</strong></em>:</p>
<ul>
<li><strong>Callback hell (infierno de callbacks):</strong> Los numerosos anidamientos de <em><strong>callbacks</strong></em> hicieron que el código pudiera volverse <strong>muy difícil de leer y mantener</strong>.</li>
<li><strong>Dificultad para depurar:</strong> En situaciones complejas, <strong>puede ser complicado rastrear el flujo de ejecución</strong>, era todo <strong>un reto</strong> el discernir qué debía ocurrir en cada momento, cuando se utilizan muchos callbacks.</li>
<li><strong>Pérdida de contexto:</strong> El contexto  <code>this</code>  dentro de un callback puede <strong>no ser el esperado</strong>.</li>
</ul>
<br>
 <br>
<img src="interrogacion.png" align="left" width="90">   <h3>¿Y  CÓMO SOLUCIONÓ JAVASCRIPT ESTE GRAN PROBLEMA?</h3>
<br>
<br>
<p>Precisamente con las <strong>promises</strong> o <strong>promesas</strong> que acabamos de explicar en el capítulo anterior.</p>
<br>
<h2 id="promesas">2. PROMESAS</h2>
<p>Las promesas <strong>resolvieron</strong> algunos asuntos como:</p>
<ul>
<li>La dificultad para <strong>manejar errores</strong></li>
<li><strong>El lío del código anidado</strong></li>
</ul>
<p>Todo ello gracias a que las <strong>promesas</strong>  constituyen operaciones asíncronas que podían manejar:</p>
<ul>
<li>Proceso de <strong>tareas con éxito</strong> -a través del método <code>then()</code></li>
<li><strong>Manejo de errores</strong> a través del método <code>catch()</code>	 .</li>
</ul>
<br>
<div align="center">
<img src="diagramaPromesa.png" alt="diagrama Promesa">
</div>
<br>
<p>No añadimos ejemplos de las <strong>promesas</strong>, ya que han quedado explicadas en el capítulo anterior.</p>
<br>
<br>
<h2 id="funciones-bigasyncbig---bigawaitbig">3. FUNCIONES <big><code>async</code></big> - <big><code>await</code></big></h2>
<p>A partir de <strong>septiembre de 2017</strong> (especificación ECMAScript2017), se incorporaron a JavaScript <strong>las palabras clave</strong> de <code>async</code> y <code>await</code> que constituyen <strong>la forma más sencilla y moderna de manejar código asincrónico</strong>:</p>
<ul>
<li><code>async</code> :  convierte una función normal en una asíncrona y <strong>devuelve una  promesa</strong>.</li>
<li><code>await</code> : se usa dentro de las funciones <code>async</code> para <strong>pausar una ejecución hasta que la Promise se resuelve</strong>.<br>
<br></li>
</ul>
<h4 id="sintaxis-básica">SINTAXIS BÁSICA:</h4>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">miFuncion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> resultado <span class="token operator">=</span> <span class="token keyword">await</span> promesa<span class="token punctuation">;</span>
  <span class="token comment">// Aquí continúa la ejecución después de que promesa se haya resuelto</span>
  <span class="token keyword">return</span> resultado<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Proporcionan:</p>
<ul>
<li><strong>Mayor legibilidad</strong>: tiene aspecto de código síncrono, lo que facilita su lectura y comprensión</li>
<li><strong>Manejo de errores</strong> de forma similar a como se haría con código <strong>síncrono</strong></li>
<li><strong>Sintaxis más limpia</strong>: <strong>elimina la necesidad de anidar</strong> <code>then()</code> y <code>catch()</code> al trabajar con promesas haciendo código más limpio y conciso.</li>
</ul>
<br>
<br>
<div align="center">
<img src="asyncAwait.png" width="60%" alt="diagrama async-await">
</div>
<br>
<br>
<h4 id="ejemplo-async--await">EJEMPLO <code>async</code>- <code>await</code>:</h4>
<p>(Evitamos incluir los <code>reject</code>  para mostrar más claramente el propósito de la explicación de <code>async</code>-<code>await</code>)</p>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">const</span> <span class="token function-variable function">login</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'User logged in...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">updateAccount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Updating last login...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">loginActivities</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> returnedLogin <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">login</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>returnedLogin<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> returnedUpdateAccount <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">updateAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>returnedUpdateAccount<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">loginActivities</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// retorna 'Updating last login...'</span>
</code></pre>
<ul>
<li>Simplemente hemos declarado una lista de <strong>cuándo queremos que cada uno de estos procesos ocurran y el orden</strong> en el que queremos que ocurran.<br>
<br></li>
</ul>
<h4 id="¿cómo-funciona-este-proceso">¿Cómo funciona este proceso?</h4>
<p><strong>1</strong>. En el primer <code>await</code>, al anteponer esta palabra clave justo ahí,  se <strong>suspenderá la ejecución de</strong> <code>async</code> hasta que la función de <code>login()</code>  , es decir, <strong>esta promesa no termine</strong> su ejecución.   Y solo después, ejecutará <code>async</code>, es decir ejecutará  <code>console.log(returnedLogin)</code>. En un mundo real devolvería las <strong>licencias del usuario, su nombre y ese tipo de cosas en lugar de un string</strong>.</p>
<p><strong>2.</strong> Como vemos, JavaScript <strong>nos permite</strong> tener una funcion <strong><code>async</code> con multiples sentencias <code>await</code></strong>.  Cada <code>await</code>  pausa la ejecución de la función asíncrona hasta que la promesa a la que se aplica <strong>se resuelva o se rechace</strong>, devolviendo el valor de la promesa resuelta. <strong>No hay límite en la cantidad de sentencias</strong> <code>await</code>  que puedan usar dentro de una función <code>async</code>.</p>
<p><strong>3.</strong> Al poner los dos <code>await</code>  <em><strong>en este orden</strong></em>, estamos <strong>estableciendo la secuencia</strong> que necesitamos que ocurra.<br>
- 	No tendría	sentido que <code>updateAccount()</code> occurriera antes que <code>login()</code> porque necesitamos los datos del <code>login()</code> para poder actualizar la cuenta, que es lo que hace la función <code>updateAccount()</code>: de hecho nos daría error.<br>
- <code>async</code>/<code>await</code>nos permite, pues,  <strong>encadenar multiples operaciones</strong> asíncronas de forma secuencial. <strong>Nosotros dictamos el orden.</strong></p>
<p><strong>4.</strong> Por tanto, el <strong>tiempo total de esta ejecucion</strong> de la función asíncrona <code>loginActivities()</code> será la <strong>suma</strong> de las dos promesas, o sea, <strong>6 segundos.</strong></p>
<br>
<p><strong><big>Se ha conseguido:</big></strong></p>
<ul>
<li>
<p><strong>Mayor capacidad de respuesta: el usuario sigue funcionando sin interrupciones</strong> mientras las demás operaciones de más larga duración terminan de completarse.</p>
</li>
<li>
<p><strong>Optimización del rendimiento: evita que el programa se bloquee esperando resultados</strong>, lo que a su vez mejora la experiencia de usuario</p>
</li>
</ul>
<br>
<img src="interrogacion.png" align="left" width="90"> <h3>  Pero.....<br>
¿Y si queremos que los todos los procesos se<br> ejecuten a la vez 
y no en secuencia?</h3><h3>
</h3><br>
<br>
<h3 id="uso-de-cierres-o-closures-con-bigasyncbig---bigawaitbig">1)  USO DE “CIERRES” O “CLOSURES” con <big><code>async</code></big> - <big><code>await</code></big></h3>
<p>Los <strong>cierres</strong> o clausuras (“closures”) en Javascript son <strong>una herramienta poderosa</strong> que, combinada con las funciones asíncronas, permite <strong>mantener el estado y acceder a variables externas</strong> en operaciones <strong>asíncronas</strong>.</p>
<p><code>Async</code>- <code>await</code>  no altera la funcionalidad de los cierres, pero <strong>puede afectar la forma en que se accede a ellos en código asíncrono</strong>.</p>
<p>"<em>Un cierre se produce cuando una función “recuerda” su ámbito léxico, es decir, las variables que estaban disponibles en el momento de su creación, incluso si esa función se ejecuta fuera de ese ámbito. En otras palabras, <strong>una función interna</strong> puede <strong>acceder a variables de su función contenedora (externa)</strong> incluso después de que la función externa haya terminado de ejecutarse.</em> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures">Para ampliar esta información, haz click aquí</a></p>
<p>Explicado de una forma sencilla, el cierre es una función <strong>que puede ser anidada (colocada dentro de una variable), y luego puede ser pasada como argumentos de otras funciones</strong>.<br>
<br></p>
<br>
<img src="interrogacion.png" align="left" width="90"> <h3>  Y.....<br>
 ¿QUÉ SIGNIFICA “MANTENER EL ESTADO DE UNA FUNCIÓN”?
</h3><h3>
</h3><br>
<h3 id="section"></h3>
<ul>
<li>En cierres o clausuras, “mantener el estado” significa que una función puede <strong>acceder a variables que estén declaradas en un ámbito superior (es decir, fuera de la función misma).</strong>
<ul>
<li>Estas variables <strong>“existen” en la memoria</strong> incluso <strong>después</strong> de que la función que las creó <strong>ha terminado de ejecutarse</strong>,</li>
<li>y pueden ser <strong>accedidas por otras funciones que estén dentro del mismo ámbito o que tengan acceso a ellas a través de referencias.</strong></li>
</ul>
</li>
<li>Es decir, en el contexto de <code>async</code> - <code>await</code>, los cierres pueden ser utilizados para <strong>mantener el estado de las variables dentro de las funciones asíncronas</strong>, permitiendo que las funciones <code>await</code> accedan a ellas.</li>
</ul>
<br>
<p><strong>VENTAJAS:</strong><br>
<br></p>
<ul>
<li>Legibilidad</li>
<li>Gestión del Código<br>
<br></li>
</ul>
<h4 id="ejemplo-1-----async-----await-con-cierres">EJEMPLO 1 -   <code>async</code>  -  <code>await</code> con cierres:</h4>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">const</span> <span class="token function-variable function">login</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'User logged in...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">updateAccount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Updating last login...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// cómo colocamos los cierres:</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">loginActivities</span><span class="token punctuation">(</span>login<span class="token punctuation">,</span> updateAccount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> returnedLogin <span class="token operator">=</span> <span class="token keyword">await</span> login<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>returnedLogin<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> returnedUpdateAccount <span class="token operator">=</span> <span class="token keyword">await</span> updateAccount<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>returnedUpdateAccount<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">loginActivities</span><span class="token punctuation">(</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">updateAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// imprime (a la vez) :</span>
<span class="token comment">//		User logged in...</span>
<span class="token comment">//		Updating last login...</span>
 
</code></pre>
<ol>
<li>
<p>El total que se tardará son <strong>4 segundos</strong> (no 6 como en el ejemplo    anterior sin los cierres).  Después de esos 4 segundos, <strong>las dos funciones imprimirían a la vez.</strong></p>
</li>
<li>
<p>Los <strong>nombres de los argumentos no tienen por qué ser los de las funciones</strong>, pero lo hacemos porque son más descriptivos así.  MOSTREMOS ESTE PUNTO CON EL SIGUIENTE EJEMPLO:</p>
</li>
</ol>
<br>
<h4 id="ejemplo-2-----async-----await-con-cierres-modificando-nombres-de-los-parámetros">EJEMPLO 2 -   <code>async</code>  -  <code>await</code> con cierres, MODIFICANDO NOMBRES DE LOS PARÁMETROS:</h4>
<br>
Para que no nos lleve a pensar que está funcionando porque son los argumentos tienen los mismos nombres que las promesas, pondremos cualquier letra en los argumentos de la función `async`:
<br>
<div align="center">
<img src="cierres.png" width="70%" alt="cierres async - await">
</div>
<br>
<p>Imprimiría <strong>exactamente igual</strong> que el ejemplo anterior. Solo se han cambiado nombres.</p>
<br>
<br>
<h4 id="ejemplo--3----async-----await-con-cierres-cambiando-el-orden-de-las-promesas">EJEMPLO  3 -  <code>async</code>  -  <code>await</code> con cierres, CAMBIANDO EL ORDEN DE LAS PROMESAS:</h4>
<div align="center">
<img src="cierres2.png" width="73%" alt="cierres async - await">
</div>
<br>
<ul>
<li>
<p>Aunque no tenga ningún sentido práctico, pero para mostrar cómo funcionaría, hemos cambiado el orden de los dos <code>await</code></p>
</li>
<li>
<p>El <strong>total</strong> de segundos seguirían siendo <strong>exactamente igual</strong> que el ejemplo anterior: 4 segundos.</p>
</li>
<li>
<p><em><strong>Sin embargo:</strong></em></p>
<ul>
<li>A los <strong>2 segundos</strong> imprimiría la función <strong><code>updateAccount()</code></strong></li>
<li><strong>Transcurridos los siguientes 2 segundos</strong>, se imprimiría <strong><code>login()</code> .</strong><br>
El tiempo estaba corriendo también para esta función <code>login()</code> más larga de 4 segundos.</li>
</ul>
</li>
</ul>
<br>
<h3 id="bigasyncbig---bigawaitbig-en-comunicaciones-api-bloque-try--catch">2)  <big><code>async</code></big> - <big><code>await</code></big> EN COMUNICACIONES API: BLOQUE <code>try{}</code>- <code>catch()</code></h3>
<ul>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Capturaremos <strong>2 URLs</strong> (endpoints APIs) utilizando el async y await.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Utilizaremos el <strong>bloque  <code>try</code> - <code>catch</code></strong></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Veremos cómo usar las funciones <strong><code>then()</code>con <code>catch()</code></strong>, pero trabajando con <strong>múltiples promesas</strong>. Combinándolos con <code>await</code> implementaremos una forma diferente de manejar los errores.<br>
<br></li>
</ul>
<h3 id="a---explicando-bloque-try---catch">A)   Explicando bloque <code>try - catch</code></h3>
<p><code>try</code>…<code>catch</code><br>
-  se utiliza para  <em><strong>capturar excepciones</strong></em>  que pueden ocurrir durante la ejecución de código en  JavaScript.<br>
- nos permite  <strong>gestionar errores que ocurren durante la ejecución</strong>, sin interrumpir el flujo general del programa  <em>(gestionándolo de forma controlada)</em>.</p>
<br>
<div align="center">
<img src="tryCatch.png" width="45%" alt="bloque try-catch">
</div>
<br>
<p>La sintaxis básica de  <code>try...catch</code>  es la siguiente:</p>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// Código que puede generar un error</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Código que se ejecuta si ocurre un error</span>
<span class="token punctuation">}</span> 
</code></pre>
<br>
<p>FUNCIONA así:</p>
<ol>
<li>Primero, se ejecuta el código en  <code>try {...}</code>.</li>
<li>Si no hubo errores, se ignora  <code>catch (err)</code>: la ejecución llega al final de  <code>try</code>  y continúa, omitiendo  <code>catch</code>.</li>
<li>Si se produce un error, la ejecución de  <code>try</code>  se detiene y el control fluye al comienzo de  <code>catch (err)</code>. La variable  <code>err</code>  (podemos usar cualquier nombre para ella) contendrá un <strong>objeto de error con detalles sobre lo que sucedió.</strong></li>
</ol>
<br>
<h4 id="ejemplo-a--todo-funcionando-bien">EJEMPLO A : todo funcionando bien</h4>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">queryApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> postsPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://jsonplaceholder.typicode.com/todos/1'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">const</span> posts <span class="token operator">=</span> <span class="token keyword">await</span> postsPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>posts<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> reposPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">' https://fakestoreapi.com/products/1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> r repos epos <span class="token operator">=</span> <span class="token keyword">await</span> reposPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>repos<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">queryApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   


</code></pre>
<br>
1.-  El orden de los dos `await` está determinado **por el orden de nuestro código**.  
Deberíamos recibir los datos de <font color="green">*jasonplaceholder*</font> y LUEGO (**y solo luego, por eso el  `await`**) **sale y contacta con la otra promesa** de <font color="green">*fakestoreapi*</font>  y devuelve los datos de ésta última.
<p>2.-  Lo bueno de esto es que <strong>da igual cuántas veces ejecutemos esto</strong>.  Incluso aunque la API de <font color="green"><em>jasonplaceholder</em></font>  funcione <strong>muy despacio</strong> (durante unos minutos por ejemplo) y la de  <font color="green"><em>fakestoreapi</em></font>  va <strong>muy rápido</strong>, siempre nos va a <strong>devolver los datos en el mismo orden que lo hemos escrito</strong> o codificado, ya que  lo hemos envuelto todo en este proceso <code>async</code> y luego aplicamos <code>await</code> a cada una de las promesas.</p>
<p>3.- Esto lo convierte <strong>en algo muy potente</strong>, cuando trabajamos con datos <strong>y no sabemos cuándo vamos a recibir los datos de la API,</strong> o de una conexión de base de datos.<br>
<br></p>
<ul>
<li>
<p>Imaginemos una situación en la que <strong>todo este proceso gire en torno a que la primera promesa</strong>:  por ejemplo si estamos autenticando con  <font color="green"><em>fakestoreapi</em></font>  y estamos enviando nuestras credenciales a  <font color="green"><em>fakestoreapi</em></font>  y <strong>resulta que cada una de las otras llamadas de API requiere esas credenciales</strong>.<br>
<strong>En esta situación es absolutamente necesario este tipo de proceso</strong>, ya que no  podríamos hacer las siguientes llamadas de API si la primera no ha podido ejecutarse,</p>
</li>
<li>
<p>Esto es parte de la razón por la que utilizando esas herramientas de <strong><code>async</code>-<code>await</code> se han convertido tan famosas en la comunidad de JavaScript</strong>, ya que gracias a ellas, tenemos <strong>el control</strong> de esto.</p>
</li>
</ul>
<br>
<p>Una vez más, si ejecuto esto unas cuantas veces seguidas, <strong>siempre</strong> :<br>
1º. - Obendremos <strong>primero</strong> nuestros datos de <font color="green"><em>jasonplaceholder</em></font>.<br>
2º.  - Y  en <strong>segundo</strong> lugar los de  <font color="green"><em>fakestoreapi</em></font> , que es lo que podemos necesitar en un momento dado.</p>
<br>
<h3 id="b---los-bloques-bigtrybig---bigcatchbig-en-comunicaciones-api.">B)   Los bloques <big><code>try()</code></big> - <big><code>catch()</code></big> en comunicaciones API.</h3>
<p>Como ya hemos mencionado, si en el ejemplo anterior funcionara todo perfectamente, ejecutaría el bloque <code>try{}</code>, el bloque de <code>catch()</code>lo ignoraría por completo.</p>
<ul>
<li>En el caso (frecuente)  de que falle una API, es muy importante poder configurar un proceso para que suceda exactamente lo que queremos.</li>
<li>Esto puede ser simplemente que <strong>al conectarse un usuario a una aplicación</strong> (que haga el “login”) <strong>le avisemos de que hay un problema.</strong>
<ul>
<li>Por ej. <em><strong>queremos generar las fotos de Instagram</strong></em> de alguien que se encuentran dentro de la página de su perfil: si hay algún problema con Instagram o alguna <strong>demora con sus APIs</strong>, estaría bien poner en algún lado del programa algo para que diga “<strong>error al contactar a Instagram</strong>”, o “<strong>por favor, inténtelo de nuevo en otro momento</strong>”, o  algo similar.</li>
</ul>
</li>
</ul>
<br>
<p>Imaginemos que <strong>hay un error</strong>, y <strong>falta la letra “s”</strong> en la primera promesa, la de <font color="green"><em>jasonplaceholder</em></font><br>
<br></p>
<h4 id="ejemplo--b---------falta-la-letra-s-en-el-https-de-la-primera-promesa">EJEMPLO  B    -    falta la letra “s” en el “https” de la PRIMERA promesa:</h4>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">queryApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> postsPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://jsonplaceholder.typicode.com/todos/1'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">const</span> posts <span class="token operator">=</span> <span class="token keyword">await</span> postsPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>posts<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> reposPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">' https://fakestoreapi.com/products/1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> r repos epos <span class="token operator">=</span> <span class="token keyword">await</span> reposPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>repos<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">queryApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//typeError: Failed to fetch</span>

</code></pre>
<ul>
<li>En este caso <strong>¡se detiene el proceso entero!.</strong>  No ha podido terminar el primero y se para todo aquí.</li>
<li>Imprime el error: <strong>typeError: Failed to fetch</strong><br>
<br></li>
</ul>
<h4 id="ejemplo--c------falta-la-letra-s-en-el-https-de-la-segunda-promesa">EJEMPLO  C  -   falta la letra “s” en el “https” de la SEGUNDA promesa:</h4>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">queryApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> postsPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://jsonplaceholder.typicode.com/todos/1'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">const</span> posts <span class="token operator">=</span> <span class="token keyword">await</span> postsPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>posts<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> reposPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">' http://fakestoreapi.com/products/1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> r repos epos <span class="token operator">=</span> <span class="token keyword">await</span> reposPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>repos<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">queryApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token comment">// datos de la primera promesa</span>
<span class="token comment">// typeError: Failed to fetch  (correspondiente a la segunda promesa)</span>

</code></pre>
<ul>
<li>Retorna <strong>los datos del primer bloque de  <code>try{}</code></strong></li>
<li>Y  también retorna <em><strong>typeError: Failed to fetch.</strong></em>  Pero <strong>no da ninguna información</strong> respecto <strong>a cuál de las promesas ha fallado exactamente</strong> . Aquí obviamente lo sabríamos por descarate, pero si tuvieramos muchas promesas, no sabríamos cuál falla.</li>
</ul>
<br>
<h4 id="ejemplo--d------envolviendo-promesas-con-los-bloques-bigtrybig---bigcatch-big-br-falta-la-letra-s-en-el-https-de-la-primera-promesa">EJEMPLO  D  -   ENVOLVIENDO PROMESAS con los bloques <big><code>try</code></big> - <big><code>catch</code> </big>, <br> falta la letra “s” en el <em>https</em> de la primera promesa</h4>
<p>1.- Envolveremos cada promesa con un bloque  <strong><code>try</code> - <code>catch</code> de forma individual</strong><br>
2.- Añadiremos <strong>la descripción</strong> precisamente para proporcionar <strong>información para la identificación del fallo</strong>.</p>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">queryApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> postsPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://jsonplaceholder.typicode.com/todos/1'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">const</span> posts <span class="token operator">=</span> <span class="token keyword">await</span> postsPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>posts<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'There was an error with the jsonplaceholder API'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> reposPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">' https://fakestoreapi.com/products/1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> r repos epos <span class="token operator">=</span> <span class="token keyword">await</span> reposPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>repos<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'There was an error with fakestoreapi API'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">queryApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 'There was an error with the jsonplaceholder API'</span>

</code></pre>
<ul>
<li>Obtendríamos los <strong>datos de la segunda promesa</strong>.</li>
<li>Y obtendríamos información sobre la <strong>razón de nuestro error de la primera promesa</strong>.</li>
</ul>
<br>
<br>
<img src="interrogacion.png" align="left" width="90">  
<h4 id="¿cuándo--envolver-las-promesas-con-bloques-try---catch-de-forma-individual-bry-cuándo-poner-todas-las-promesas-en-un-solo-bloque-try---catch">¿CUÁNDO  ENVOLVER LAS PROMESAS CON BLOQUES <code>try{}</code> - <code>catch()</code> DE FORMA INDIVIDUAL <br>Y CUÁNDO PONER TODAS LAS PROMESAS EN UN SOLO BLOQUE <code>try{}</code> - <code>catch()</code>?</h4>
<br>
<p>Para diferenciar cuándo envolver todas las promesas en un solo  <strong><code>try</code> - <code>catch</code></strong>  o un bloque de este tipo individualmente para cada promesa, podemos tener diferentes situaciones:</p>
<ol>
<li>
<p>Si necesitamos <strong>que se detenga el proceso entero</strong> al incurrir en algún error, y que no siga ejecutando las demás funciones.</p>
<ul>
<li>Por ejemplo <strong>si las promesas están conectadas</strong>, como sería el caso de <strong>una autentificación para la segunda promesa</strong> (aquí    <font color="green"><em>fakestoreapi</em></font>).</li>
</ul>
<p>Sería una situación donde <strong>no querríamos envolverlas individualmente</strong>, ya que <strong>no debería iniciarse ningún otro proceso sin tener credenciales de usuario</strong>.</p>
</li>
<li>
<p>Pero el tipo de situación de los ejemplos mencionados, donde <strong>estamos contactando con dos APIs diferentes</strong>, entonces si una falla, es posible que, de todas formas,  <strong>quisiéramos contactar con la que no falla</strong>, y en este caso, <strong>necesitaríamos envolverlas</strong> con el bloque <strong><code>try</code>- <code>catch</code> de forma individual.</strong></p>
</li>
</ol>
<hr>
<h1 id="b-ejercicios-prácticos-checkpoint-8">B) EJERCICIOS PRÁCTICOS CHECKPOINT 8</h1>
<pre class=" language-js"><code class="prism  language-js"><span class="token comment">/*  EJERCICIO 1
 Cree un bucle for en JS que imprima cada nombre en esta lista.
 miLista = “velma”, “exploradora”, “jane”, “john”, “harry”
 */</span>

 <span class="token keyword">const</span> miLista <span class="token operator">=</span> <span class="token punctuation">[</span>
   <span class="token string">"velma"</span><span class="token punctuation">,</span>
   <span class="token string">"exploradora"</span><span class="token punctuation">,</span>
   <span class="token string">"jane"</span><span class="token punctuation">,</span>
   <span class="token string">"john"</span><span class="token punctuation">,</span>
   <span class="token string">"harry"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 

miLista<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elemento<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>elemento<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/*  EJERCICIO 2

Cree un bucle while que recorra la misma lista 
y también imprima los nombres. 
Nota: Recuerda crear un contador para que el ciclo no sea infinito.
*/</span>


<span class="token keyword">var</span> miDiario <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"lunes"</span><span class="token punctuation">,</span><span class="token string">"martes"</span><span class="token punctuation">,</span><span class="token string">"miércoles"</span><span class="token punctuation">,</span> <span class="token string">"jueves"</span><span class="token punctuation">,</span> <span class="token string">"sabado"</span><span class="token punctuation">,</span> <span class="token string">"domingo"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> item <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>item <span class="token operator">&lt;</span> miDiario<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>miDiario<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> item<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">/*  EJERCICIO 3
Cree una función de flecha que devuelva "Hola mundo".
*/</span>

<span class="token function-variable function">holaMundo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hola mundo"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">holaMundo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
</div>
</body>

</html>
